functor SdmlLrValsFun(structure Token : TOKEN)
 : sig structure ParserData : PARSER_DATA
       structure Tokens : Sdml_TOKENS
   end
 = 
struct
structure ParserData=
struct
structure Header = 
struct
(* AUTOMATICALLY GENERATED BY src/sdml/silly *)
(* DO NOT EDIT THIS FILE -- edit Stardust.silly.grm instead *)
(* StardustML grammar *)
(* Uses preprocessing directives removed by the `silly' script, *)
(*  which you need to run by hand* after editing this file. *)

(* * or with:
   OS.Process.system "cd sdml;./silly";
*)

val {dprint, dprnt} =
        Debug.register {full_name= "grammar",
                        short_name= "grammar"}

local
    val index = Option.valOf (Debug.from "grammar")
in
    fun fail s =
        Debug.makeFail index s
end

 
open Sdml 
structure CC = Sdml.ConcreteContext
structure F = Fixity
structure X = Indexing

val decslevel = ref 0

fun mungeEnvForFwdRef env string =
   ( (* print ("mungeEnvForFwdRef " ^ string ^ "\n"); *)
     case ParseLib.Pvar.lookup_soft env string of
       NONE => ()
     | SOME (ParseLib.Ordvar (_, pvstatus as ref ParseLib.Neutral), pv) =>
              let val _ = "Declared but undefined variable: this is a forward reference:"
                  val _ = "  change it to `FutureFun'."
                  val _ = dprnt "Neutral (---> FutureFun)"
              in
                  pvstatus := ParseLib.FutureFun
              end
     | SOME (ParseLib.Ordvar (_, ref ParseLib.FutureFun), pv) => dprnt "FutureFun"
     | SOME (ParseLib.Ordvar (_, ref ParseLib.DefinedFun), pv) => dprnt "DefinedFun"
     | SOME (ParseLib.Ordvar (_, ref ParseLib.DefinedVal), pv) => dprnt "DefinedVal"
     | SOME (ParseLib.Convar, pv) => dprnt "Convar"
   )

(* Valid sequences of declarations:

      anything of the form

           val*  fun*  val*

      with all other declarations arbitrarily interspersed.
*)
fun check_decs ds =
    let
        fun applyFix f x =
           ( (* print (Print.p Print.printDecs x ^ "\n"); *)
            case f x of
                SOME x' => applyFix f x'
              | NONE => x
           )

        fun rotateValsOverFuns [] = NONE
          | rotateValsOverFuns ((d1 as (_, Dec(_, ValKW, _)))
                                             :: (d2 as (_, Dec(_, FunKW, _)))
                                             :: ds)
            =
              (SOME (d2 :: d1 :: ds))
          | rotateValsOverFuns (d :: ds) =
                let in
                    case rotateValsOverFuns ds of
                        NONE => NONE
                      | SOME ds => SOME (d :: ds)
                end
        
        fun check0 [] = []
          | check0 ((d as (_, Dec(_,ValKW,_))) :: ds) = d :: check2 ds
          | check0 ((d as (_, Dec(_,FunKW,_))) :: ds) = d :: check1 ds
          | check0 (d :: ds) = d :: check0 ds

        and check1 [] = []
          | check1 ((d as (_, Dec(_,ValKW,_))) :: ds) = d :: check2 ds
          | check1 ((d as (_, Dec(_,FunKW,_))) :: ds) = d :: check1 ds
          | check1 (d :: ds) = d :: check1 ds

        and check2 [] = []
          | check2 ((d as (_, Dec(_,ValKW,_))) :: ds) = d :: check2 ds
          | check2 ((d as (_, Dec(_,FunKW,_))) :: _) = raise Option
          | check2 (d :: ds) = d :: check2 ds

        val check = check0

        val _ = dprint (fn () => Print.p Print.printDecs ds)
        val rotated_ds = applyFix rotateValsOverFuns ds
        val _ = dprint (fn () => Print.p Print.printDecs rotated_ds)
    in
        ((*check*) rotated_ds)
        handle Option =>
            (print ("Declarations invalid: `val' mixed with block of `fun's\n");
             raise Option)
    end

fun var'n'fix env s errexp =
    let val (info, pv) = ParseLib.Pvar.lookup errexp env s
        val f = pv
    in
        (case info of
             ParseLib.Convar => Con pv
           | ParseLib.Ordvar _ => Var pv,
             f)
    end


(* cf. Definition of Standard ML, p. 72, and
   http://www.standardml.org/Basis/top-level-chapter.html
*)
fun fixityfn pv =
    case PV.proper_name pv of
        "*" => F.infixleft 7
      | "/" => F.infixleft 7
      | "div" => F.infixleft 7
      | "mod" => F.infixleft 7

      | "+" => F.infixleft 6
      | "-" => F.infixleft 6
      | "^" => F.infixleft 6

      | "<" => F.infixleft 4
      | ">" => F.infixleft 4
      | "<=" => F.infixleft 4
      | ">=" => F.infixleft 4
      | "<>" => F.infixleft 4
      | "=" => F.infixleft 4

      | _ => F.NONfix


fun unflatten locexps =
    let fun applyFn ((loc1,e1), (loc2, e2)) =
           let val loc = Location.span loc1 loc2
           in
               (loc,
                let in case e1 of
                    Con c => Conapp(c, (loc2,e2))
                  | _ => App((loc1,e1), (loc2,e2))
                end)
           end

        fun pairFn ((loc1,e1), (loc2,e2)) =
              (Location.span loc1 loc2,
               Tuple[(loc1,e1), (loc2,e2)])

        val locexp = Precedence.parse PV.proper_name {apply= applyFn, pair= pairFn} (locexps, fixityfn)
    in
        locexp
    end


val X_var'n'fix = let
fun X_var'n'fix env s errexp =
    let val (iv, syminfo) = ParseLib.lookup_iv errexp env s
(* val xxx = print ("`" ^ s ^ "' X_var'n'fix " ^ IndexSym.toString iv ^ "\n") *)
        val f = iv (* case ParseLib.Pvar.lookup_soft env (IndexSym.toShortString iv) of
            SOME (_, f) => f
          | NONE => ~1 *)
        val exp = case syminfo of 
            X.IUVar _ => X.Uvar iv
          | X.IEVar _ => X.Evar iv
          | X.INil _ => X.Nil iv
          | X.ITrue => X.True
          | X.IFalse => X.False
          | X.INODIM => X.NODIM
          | X.IBaseDim => X.BaseDim iv
          | X.IFun _ => X.Uvar iv  (* bogus? *)
    in
        (exp, f)
    end
in
    X_var'n'fix : (ParseLib.env -> string -> (string -> unit) -> (Indexing.exp * IndexSym.sym))
end

fun X_fixityfn iv =
    case IndexSym.toShortString iv of
        "+" => F.infixleft 6
      | "-" => F.infixleft 6
      | "*" => F.infixleft 7
      | "/" => F.infixleft 7
      | "<" => F.infixleft 4
      | ">" => F.infixleft 4
      | "<=" => F.infixleft 4
      | ">=" => F.infixleft 4
      | "<>" => F.infixleft 4
      | "=" => F.infixleft 4   (* XXX  don't have Definition with me right now; is this right? *)
(*      | "/\\" => F.infixleft 3   (* XXX *)
      | "\\/" => F.infixleft 3   (* XXX *)
*)
      | "^" => F.infixright 8   (* power; probably inconsistent with ^ operator in ML, but that's string concatenation, so who's counting? *)
      | _ => F.NONfix

fun X_unflatten exps =
    let fun applyFn (e1, e2) =
                let in case e1 of
                    X.Uvar v => X.App(v, e2)
                  | _ => (print ("X_unflatten dying on index expression ``" ^ X.Exp.toString e1 ^ "'' \n");
                          raise Option)
                end
        val exp = Precedence.parse (IndexSym.toString) {apply= applyFn,
                                       pair= fn (e1, e2) => (X.Tuple [e1, e2])
                                     } (exps, X_fixityfn)
    in
        exp
    end


structure Stringdec = struct
  datatype t =
 (*   Dec of (string * PV.sym) * (ParseLib.env -> Sdml.locexp)
  | *)
    ValType of (string * PV.sym) * Dectype.dectype
  | Datacon of (string * PV.sym) * (ParseLib.env -> Sdml.texp)
  | TyvarVariance of string * Sdml.Variance.t
  | DatatypeWith of string * Indexing.Sorting.t

  type loct = Location.location * t
  
  fun getVariance defaultVariance tvname stringdecs =
    let val self = getVariance defaultVariance tvname
    in case stringdecs of
        [] => defaultVariance
      | (loc, TyvarVariance (tvname', variance)) :: rest => if tvname = tvname' then variance else self rest
      | _ :: rest => self rest
    end

  fun getSorting tcname stringdecs = case stringdecs of
     [] => X.Sorting.None
   | (loc, DatatypeWith (tcname', sorting)) :: rest => if tcname = tcname' then sorting else getSorting tcname rest
   | _ :: rest => getSorting tcname rest

  fun frobDatacon env stringdec = case stringdec of 
     (loc, Datacon ((string, pv), texpSusp)) => SOME (string, (pv, texpSusp env))
   | _ => NONE

  fun getValtypes stringdecs = List.mapPartial (fn (loc, ValType ((_, pv), dectype)) => SOME (loc, Sdml.ValType(pv, dectype))
                                                                     | _ => NONE) stringdecs

  fun getValtype stringdecs string =
    let val matches = List.mapPartial (fn (loc, ValType ((string', pv), dectype)) =>
                                                                                                 if string = string' then SOME (pv, dectype) else NONE
                                                                                    | _ => NONE) stringdecs
    in
      case matches of
         [] => NONE
       | [onlyMatch] => SOME onlyMatch
       | multipleMatches => fail ("Multiple type annotations for same val " ^ string)
    end

  val getValtype = getValtype : loct list -> string -> (PV.sym * Dectype.dectype) option
end (* structure StringDec *)
    

fun buildSynonym env
                                ((*typbind*) list : (TC.sym * (ParseLib.env -> (((string * TV.sym) list * texp)))) list)
                                location
=
    let val (tcs, infos) = (ListPair.unzip list) :  TC.sym list * (ParseLib.env -> (((string * TV.sym) list * texp))) list
        val (bindings, algFns) = ListPair.unzip
                                     (List.map (fn (tc, entry) =>
                                                   let val fresh_tv = TV.fresh (TC.toShortString tc)
                                                   in
                                                       ((TC.toShortString tc, ParseLib.TypeSynonym (tc, fresh_tv))
                                                      ,
                                                       fn env =>
                                                          let val (params, texp) = entry env
                                                              val (paramNames, paramTVs) = ListPair.unzip params
                                                          in
                                                              Sdml.Synonym{tc= tc,
                                                                                       tv= fresh_tv,
                                                                                       params= paramTVs,
                                                                                       definition= texp}
                                                          end
                                                           )
                                                       end)
                                               list)
        val withTCs = ParseLib.Type.extend env bindings
        val typedecs = List.map (fn f => f withTCs) algFns
        val result = [(location, Typedec typedecs)] : decs
    in
        (withTCs, result)
        :
        ParseLib.env * decs
    end


end
structure LrTable = Token.LrTable
structure Token = Token
local open LrTable in 
val table=let val actionRows =
"\
\\001\000\001\000\000\000\000\000\
\\001\000\002\000\028\000\004\000\102\000\049\000\027\000\057\000\026\000\
\\058\000\101\000\063\000\100\000\064\000\187\000\065\000\025\000\
\\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\102\000\049\000\027\000\057\000\026\000\
\\058\000\101\000\063\000\100\000\065\000\025\000\066\000\024\000\
\\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\011\000\148\000\018\000\147\000\021\000\146\000\
\\027\000\145\000\028\000\144\000\035\000\143\000\039\000\142\000\
\\043\000\141\000\049\000\027\000\056\000\140\000\057\000\026\000\
\\058\000\139\000\059\000\138\000\061\000\137\000\063\000\136\000\
\\064\000\232\000\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\011\000\148\000\018\000\147\000\021\000\146\000\
\\027\000\145\000\028\000\144\000\035\000\143\000\039\000\142\000\
\\043\000\141\000\049\000\027\000\056\000\140\000\057\000\026\000\
\\058\000\139\000\059\000\138\000\061\000\137\000\063\000\136\000\
\\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\011\000\148\000\021\000\146\000\027\000\145\000\
\\028\000\144\000\035\000\143\000\039\000\142\000\043\000\141\000\
\\049\000\027\000\056\000\140\000\057\000\026\000\058\000\139\000\
\\059\000\138\000\061\000\137\000\063\000\136\000\065\000\025\000\
\\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\021\000\146\000\027\000\145\000\028\000\144\000\
\\035\000\143\000\039\000\142\000\049\000\027\000\056\000\140\000\
\\057\000\026\000\058\000\139\000\059\000\138\000\061\000\137\000\
\\063\000\136\000\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\027\000\145\000\028\000\144\000\035\000\143\000\
\\039\000\142\000\049\000\027\000\056\000\140\000\057\000\026\000\
\\058\000\139\000\059\000\138\000\061\000\137\000\063\000\136\000\
\\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\027\000\145\000\028\000\144\000\039\000\142\000\
\\049\000\027\000\056\000\140\000\057\000\026\000\058\000\139\000\
\\059\000\138\000\061\000\137\000\063\000\136\000\065\000\025\000\
\\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\027\000\145\000\028\000\144\000\049\000\027\000\
\\057\000\026\000\058\000\139\000\059\000\138\000\061\000\137\000\
\\063\000\136\000\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\049\000\027\000\054\000\068\000\057\000\026\000\
\\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\049\000\027\000\057\000\026\000\063\000\119\000\
\\065\000\025\000\066\000\024\000\069\000\023\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\049\000\027\000\057\000\026\000\064\000\215\000\
\\065\000\025\000\066\000\024\000\069\000\023\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\049\000\027\000\057\000\026\000\065\000\025\000\
\\066\000\024\000\069\000\023\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\049\000\027\000\057\000\026\000\065\000\025\000\
\\066\000\024\000\076\000\022\000\000\000\
\\001\000\002\000\028\000\049\000\027\000\057\000\212\000\063\000\119\000\
\\065\000\025\000\066\000\024\000\069\000\023\000\076\000\022\000\000\000\
\\001\000\002\000\053\000\000\000\
\\001\000\002\000\053\000\003\000\052\000\041\000\051\000\059\000\050\000\
\\061\000\049\000\063\000\048\000\073\000\047\000\074\000\046\000\
\\079\000\045\000\080\000\044\000\000\000\
\\001\000\002\000\053\000\003\000\052\000\041\000\051\000\059\000\050\000\
\\061\000\049\000\063\000\048\000\073\000\047\000\074\000\046\000\
\\080\000\044\000\000\000\
\\001\000\002\000\053\000\003\000\052\000\041\000\051\000\059\000\050\000\
\\063\000\048\000\073\000\047\000\074\000\046\000\000\000\
\\001\000\002\000\090\000\000\000\
\\001\000\002\000\093\000\003\000\092\000\000\000\
\\001\000\002\000\106\000\000\000\
\\001\000\002\000\106\000\059\000\105\000\000\000\
\\001\000\002\000\158\000\003\000\052\000\041\000\051\000\059\000\050\000\
\\061\000\049\000\063\000\048\000\070\000\156\000\073\000\047\000\
\\074\000\046\000\079\000\045\000\080\000\044\000\000\000\
\\001\000\002\000\158\000\003\000\052\000\041\000\051\000\059\000\050\000\
\\061\000\049\000\063\000\157\000\070\000\156\000\073\000\047\000\
\\074\000\046\000\079\000\045\000\080\000\044\000\000\000\
\\001\000\002\000\205\000\041\000\204\000\059\000\203\000\061\000\202\000\
\\063\000\201\000\000\000\
\\001\000\002\000\205\000\059\000\084\001\061\000\202\000\063\000\201\000\000\000\
\\001\000\002\000\220\000\000\000\
\\001\000\002\000\238\000\000\000\
\\001\000\002\000\240\000\004\000\239\000\000\000\
\\001\000\002\000\242\000\000\000\
\\001\000\002\000\251\000\000\000\
\\001\000\002\000\005\001\000\000\
\\001\000\002\000\027\001\000\000\
\\001\000\002\000\039\001\000\000\
\\001\000\002\000\100\001\000\000\
\\001\000\002\000\123\001\004\000\122\001\006\000\121\001\049\000\027\000\
\\057\000\026\000\061\000\120\001\063\000\119\001\064\000\151\001\
\\065\000\025\000\066\000\024\000\069\000\118\001\076\000\022\000\000\000\
\\001\000\002\000\123\001\004\000\122\001\006\000\121\001\049\000\027\000\
\\057\000\026\000\061\000\120\001\063\000\119\001\065\000\025\000\
\\066\000\024\000\069\000\118\001\076\000\022\000\000\000\
\\001\000\002\000\136\001\000\000\
\\001\000\003\000\075\000\000\000\
\\001\000\003\000\007\001\000\000\
\\001\000\004\000\188\000\000\000\
\\001\000\006\000\217\000\000\000\
\\001\000\006\000\132\001\000\000\
\\001\000\008\000\183\000\033\000\182\000\060\000\017\001\000\000\
\\001\000\008\000\183\000\033\000\182\000\060\000\183\001\000\000\
\\001\000\008\000\183\000\033\000\182\000\062\000\181\000\000\000\
\\001\000\015\000\142\001\000\000\
\\001\000\016\000\146\001\000\000\
\\001\000\017\000\001\001\000\000\
\\001\000\017\000\144\001\000\000\
\\001\000\017\000\145\001\000\000\
\\001\000\017\000\180\001\000\000\
\\001\000\019\000\057\000\040\000\056\000\042\000\055\000\000\000\
\\001\000\020\000\056\001\000\000\
\\001\000\022\000\087\000\030\000\086\000\057\000\085\000\000\000\
\\001\000\022\000\170\000\000\000\
\\001\000\022\000\057\001\000\000\
\\001\000\022\000\058\001\000\000\
\\001\000\031\000\061\001\000\000\
\\001\000\038\000\059\001\000\000\
\\001\000\048\000\031\001\000\000\
\\001\000\050\000\163\001\000\000\
\\001\000\051\000\113\000\000\000\
\\001\000\051\000\114\000\000\000\
\\001\000\051\000\122\000\000\000\
\\001\000\051\000\123\000\000\000\
\\001\000\051\000\192\000\000\000\
\\001\000\051\000\193\000\000\000\
\\001\000\051\000\206\000\000\000\
\\001\000\051\000\004\001\000\000\
\\001\000\051\000\008\001\000\000\
\\001\000\051\000\023\001\000\000\
\\001\000\051\000\055\001\000\000\
\\001\000\051\000\063\001\000\000\
\\001\000\051\000\081\001\000\000\
\\001\000\051\000\088\001\060\000\087\001\000\000\
\\001\000\052\000\014\001\064\000\013\001\000\000\
\\001\000\052\000\048\001\064\000\047\001\000\000\
\\001\000\053\000\060\001\000\000\
\\001\000\053\000\143\001\000\000\
\\001\000\053\000\148\001\000\000\
\\001\000\057\000\069\000\000\000\
\\001\000\057\000\110\000\000\000\
\\001\000\057\000\159\000\000\000\
\\001\000\057\000\052\001\000\000\
\\001\000\057\000\078\001\000\000\
\\001\000\057\000\135\001\000\000\
\\001\000\060\000\189\000\000\000\
\\001\000\060\000\050\001\000\000\
\\001\000\060\000\077\001\000\000\
\\001\000\060\000\087\001\000\000\
\\001\000\062\000\002\001\000\000\
\\001\000\062\000\049\001\000\000\
\\001\000\062\000\086\001\000\000\
\\001\000\062\000\173\001\000\000\
\\001\000\063\000\015\001\000\000\
\\001\000\063\000\053\001\000\000\
\\001\000\063\000\054\001\000\000\
\\001\000\064\000\160\000\000\000\
\\001\000\064\000\179\000\000\000\
\\001\000\064\000\012\001\000\000\
\\001\000\064\000\033\001\000\000\
\\001\000\064\000\046\001\000\000\
\\001\000\064\000\064\001\000\000\
\\001\000\064\000\085\001\000\000\
\\001\000\064\000\129\001\000\000\
\\001\000\064\000\140\001\000\000\
\\001\000\064\000\141\001\000\000\
\\001\000\064\000\181\001\000\000\
\\001\000\065\000\006\001\000\000\
\\001\000\065\000\127\001\000\000\
\\001\000\065\000\128\001\000\000\
\\001\000\071\000\156\001\000\000\
\\001\000\072\000\125\001\000\000\
\\186\001\000\000\
\\189\001\000\000\
\\190\001\000\000\
\\191\001\000\000\
\\192\001\000\000\
\\193\001\057\000\080\001\000\000\
\\194\001\000\000\
\\195\001\002\000\022\001\041\000\204\000\059\000\203\000\061\000\202\000\
\\063\000\201\000\000\000\
\\195\001\002\000\178\001\000\000\
\\196\001\000\000\
\\197\001\000\000\
\\198\001\044\000\195\000\000\000\
\\199\001\000\000\
\\200\001\000\000\
\\201\001\008\000\067\001\000\000\
\\202\001\000\000\
\\203\001\000\000\
\\204\001\057\000\121\000\000\000\
\\205\001\000\000\
\\206\001\000\000\
\\207\001\000\000\
\\208\001\000\000\
\\209\001\000\000\
\\210\001\000\000\
\\211\001\000\000\
\\212\001\000\000\
\\213\001\000\000\
\\214\001\000\000\
\\215\001\000\000\
\\216\001\000\000\
\\217\001\000\000\
\\218\001\000\000\
\\219\001\012\000\016\000\013\000\015\000\014\000\014\000\019\000\013\000\
\\023\000\012\000\024\000\011\000\025\000\010\000\026\000\009\000\
\\034\000\008\000\037\000\007\000\040\000\006\000\042\000\005\000\000\000\
\\220\001\000\000\
\\221\001\000\000\
\\222\001\000\000\
\\223\001\000\000\
\\224\001\000\000\
\\224\001\046\000\072\000\051\000\071\000\000\000\
\\225\001\000\000\
\\226\001\000\000\
\\227\001\000\000\
\\228\001\000\000\
\\229\001\000\000\
\\230\001\000\000\
\\231\001\055\000\228\000\000\000\
\\232\001\000\000\
\\233\001\000\000\
\\234\001\000\000\
\\235\001\000\000\
\\236\001\000\000\
\\237\001\000\000\
\\238\001\000\000\
\\239\001\067\000\227\000\000\000\
\\240\001\000\000\
\\241\001\000\000\
\\242\001\000\000\
\\243\001\009\000\226\000\033\000\225\000\000\000\
\\244\001\000\000\
\\245\001\000\000\
\\246\001\000\000\
\\247\001\051\000\224\000\000\000\
\\248\001\000\000\
\\249\001\000\000\
\\250\001\000\000\
\\251\001\000\000\
\\252\001\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\027\000\145\000\028\000\144\000\049\000\027\000\
\\057\000\026\000\058\000\139\000\059\000\138\000\061\000\137\000\
\\063\000\136\000\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\253\001\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\027\000\145\000\028\000\144\000\049\000\027\000\
\\057\000\026\000\058\000\139\000\059\000\138\000\061\000\137\000\
\\063\000\136\000\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\254\001\000\000\
\\255\001\000\000\
\\000\002\000\000\
\\001\002\000\000\
\\002\002\052\000\051\001\000\000\
\\003\002\000\000\
\\004\002\000\000\
\\005\002\000\000\
\\006\002\000\000\
\\007\002\000\000\
\\008\002\000\000\
\\009\002\000\000\
\\010\002\000\000\
\\011\002\000\000\
\\012\002\000\000\
\\013\002\000\000\
\\014\002\000\000\
\\015\002\000\000\
\\016\002\000\000\
\\017\002\052\000\048\001\000\000\
\\018\002\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\011\000\148\000\018\000\147\000\021\000\146\000\
\\027\000\145\000\028\000\144\000\035\000\143\000\039\000\142\000\
\\043\000\141\000\049\000\027\000\056\000\140\000\057\000\026\000\
\\058\000\139\000\059\000\138\000\061\000\137\000\063\000\136\000\
\\065\000\025\000\066\000\024\000\076\000\022\000\000\000\
\\019\002\050\000\149\001\000\000\
\\020\002\000\000\
\\021\002\000\000\
\\022\002\000\000\
\\023\002\000\000\
\\024\002\000\000\
\\025\002\000\000\
\\026\002\000\000\
\\027\002\000\000\
\\028\002\000\000\
\\029\002\000\000\
\\030\002\054\000\147\001\000\000\
\\031\002\000\000\
\\032\002\052\000\172\001\000\000\
\\033\002\000\000\
\\034\002\002\000\123\001\004\000\122\001\006\000\121\001\049\000\027\000\
\\057\000\026\000\061\000\120\001\063\000\119\001\065\000\025\000\
\\066\000\024\000\069\000\118\001\076\000\022\000\000\000\
\\035\002\000\000\
\\036\002\000\000\
\\037\002\000\000\
\\038\002\000\000\
\\039\002\000\000\
\\040\002\052\000\034\001\000\000\
\\041\002\000\000\
\\042\002\000\000\
\\043\002\052\000\048\001\000\000\
\\044\002\000\000\
\\045\002\008\000\183\000\033\000\182\000\000\000\
\\046\002\000\000\
\\047\002\000\000\
\\048\002\000\000\
\\049\002\003\000\033\000\063\000\032\000\000\000\
\\050\002\000\000\
\\051\002\000\000\
\\052\002\003\000\037\001\000\000\
\\053\002\052\000\161\000\000\000\
\\054\002\000\000\
\\055\002\075\000\083\000\077\000\082\000\000\000\
\\056\002\000\000\
\\057\002\000\000\
\\058\002\000\000\
\\059\002\000\000\
\\060\002\048\000\081\000\000\000\
\\061\002\000\000\
\\062\002\000\000\
\\063\002\000\000\
\\064\002\000\000\
\\065\002\052\000\175\000\000\000\
\\066\002\000\000\
\\067\002\052\000\177\000\000\000\
\\068\002\000\000\
\\069\002\061\000\089\000\000\000\
\\070\002\049\000\080\000\000\000\
\\071\002\000\000\
\\072\002\000\000\
\\073\002\076\000\079\000\078\000\078\000\000\000\
\\074\002\000\000\
\\075\002\000\000\
\\076\002\000\000\
\\077\002\000\000\
\\078\002\000\000\
\\079\002\000\000\
\\080\002\052\000\190\000\000\000\
\\081\002\000\000\
\\082\002\000\000\
\\083\002\000\000\
\\084\002\000\000\
\\085\002\000\000\
\\086\002\000\000\
\\087\002\000\000\
\\088\002\000\000\
\\089\002\000\000\
\\090\002\000\000\
\\091\002\000\000\
\\092\002\002\000\053\000\003\000\052\000\041\000\051\000\063\000\048\000\
\\073\000\047\000\074\000\046\000\000\000\
\\093\002\000\000\
\\093\002\051\000\254\000\000\000\
\\094\002\000\000\
\\094\002\002\000\123\001\004\000\122\001\006\000\121\001\010\000\155\001\
\\049\000\027\000\057\000\026\000\061\000\120\001\063\000\119\001\
\\065\000\025\000\066\000\024\000\069\000\118\001\076\000\022\000\000\000\
\\095\002\000\000\
\\096\002\000\000\
\\097\002\000\000\
\\098\002\000\000\
\\098\002\002\000\028\000\004\000\152\000\005\000\151\000\006\000\150\000\
\\007\000\149\000\011\000\148\000\018\000\147\000\021\000\146\000\
\\027\000\145\000\028\000\144\000\035\000\143\000\039\000\142\000\
\\043\000\141\000\056\000\140\000\058\000\139\000\059\000\138\000\
\\061\000\137\000\063\000\136\000\000\000\
\\099\002\000\000\
\\100\002\000\000\
\\101\002\067\000\038\001\000\000\
\\102\002\000\000\
\\103\002\046\000\112\000\000\000\
\\104\002\000\000\
\\105\002\000\000\
\\106\002\052\000\030\001\000\000\
\\107\002\000\000\
\\108\002\052\000\090\001\000\000\
\\109\002\000\000\
\\110\002\000\000\
\\111\002\000\000\
\\112\002\000\000\
\\113\002\049\000\098\001\065\000\097\001\066\000\096\001\000\000\
\\114\002\000\000\
\\115\002\000\000\
\\116\002\000\000\
\\117\002\006\000\132\001\000\000\
\\118\002\000\000\
\\119\002\000\000\
\\120\002\006\000\197\000\000\000\
\\121\002\000\000\
\\122\002\000\000\
\\123\002\000\000\
\\124\002\049\000\024\001\000\000\
\\125\002\000\000\
\\126\002\000\000\
\\126\002\051\000\081\001\000\000\
\\127\002\000\000\
\\128\002\000\000\
\\129\002\000\000\
\\130\002\000\000\
\\131\002\002\000\028\000\004\000\102\000\049\000\027\000\057\000\026\000\
\\058\000\101\000\063\000\100\000\065\000\025\000\066\000\024\000\
\\076\000\022\000\000\000\
\\132\002\002\000\028\000\004\000\102\000\049\000\027\000\057\000\026\000\
\\058\000\101\000\063\000\100\000\065\000\025\000\066\000\024\000\
\\076\000\022\000\000\000\
\\133\002\000\000\
\\134\002\000\000\
\\135\002\000\000\
\\136\002\000\000\
\\137\002\000\000\
\\138\002\000\000\
\\139\002\000\000\
\\140\002\000\000\
\\141\002\052\000\014\001\000\000\
\\142\002\000\000\
\\143\002\052\000\003\001\000\000\
\\144\002\000\000\
\\145\002\055\000\250\000\000\000\
\\146\002\000\000\
\\147\002\000\000\
\\148\002\000\000\
\\148\002\064\000\179\000\000\000\
\\149\002\000\000\
\\150\002\000\000\
\\151\002\000\000\
\"
val actionRowNumbers =
"\148\000\116\000\148\000\013\000\
\\235\000\017\000\054\000\014\000\
\\014\000\014\000\014\000\014\000\
\\016\000\016\000\010\000\147\000\
\\145\000\144\000\083\000\154\000\
\\032\001\155\000\028\001\029\001\
\\030\001\027\001\025\001\016\000\
\\143\000\131\000\040\000\233\000\
\\022\001\011\001\005\001\003\001\
\\000\001\246\000\243\000\241\000\
\\056\000\255\000\020\000\021\000\
\\020\001\019\001\017\000\002\000\
\\023\000\018\001\016\001\023\001\
\\142\000\014\000\016\000\014\000\
\\084\000\036\001\064\000\065\000\
\\146\000\011\000\133\000\066\000\
\\067\000\156\000\157\000\004\000\
\\025\000\149\000\150\000\085\000\
\\100\000\239\000\014\001\022\001\
\\019\000\019\000\019\000\018\000\
\\018\000\018\000\017\000\119\000\
\\057\000\117\000\017\001\002\000\
\\251\000\242\000\253\000\251\000\
\\101\000\065\001\064\001\230\000\
\\047\000\066\001\001\000\042\000\
\\071\001\089\000\010\001\002\000\
\\068\000\069\000\127\000\053\001\
\\026\000\070\000\014\000\026\000\
\\026\000\015\000\158\000\223\000\
\\153\000\012\000\127\000\043\000\
\\028\000\017\000\182\000\181\000\
\\177\000\173\000\171\000\169\000\
\\167\000\166\000\164\000\161\000\
\\152\000\183\000\003\000\204\000\
\\029\000\030\000\009\000\031\000\
\\004\000\008\000\025\000\148\000\
\\007\000\011\000\006\000\192\000\
\\191\000\190\000\189\000\151\000\
\\079\001\082\001\032\000\025\000\
\\024\001\017\000\234\000\040\000\
\\021\001\007\001\006\001\004\001\
\\247\000\245\000\244\000\050\000\
\\118\000\093\000\078\001\077\001\
\\071\000\033\000\111\000\041\000\
\\072\000\015\001\067\001\018\000\
\\002\000\002\000\068\001\102\000\
\\078\000\069\001\097\000\013\001\
\\022\000\045\000\017\000\017\000\
\\047\001\123\000\073\000\052\001\
\\054\001\057\001\137\000\026\000\
\\026\000\034\000\055\001\059\001\
\\026\000\037\001\039\001\062\000\
\\139\000\159\000\031\001\103\000\
\\226\000\225\000\238\000\132\000\
\\136\000\034\001\035\000\133\000\
\\184\000\178\000\017\000\008\000\
\\008\000\006\000\005\000\185\000\
\\104\000\079\000\198\000\094\000\
\\202\000\203\000\090\000\188\000\
\\086\000\098\000\099\000\179\000\
\\074\000\055\000\176\000\058\000\
\\059\000\061\000\080\000\060\000\
\\025\000\075\000\105\000\083\001\
\\017\000\130\000\240\000\141\000\
\\254\000\002\000\026\000\251\000\
\\017\000\253\000\026\000\002\001\
\\232\000\231\000\073\001\072\001\
\\002\000\002\000\009\001\091\000\
\\008\001\087\000\121\000\125\000\
\\060\001\017\000\027\000\106\000\
\\095\000\077\000\041\001\138\000\
\\026\000\026\000\160\000\224\000\
\\013\000\134\000\238\000\046\001\
\\028\000\036\000\135\000\086\001\
\\174\000\175\000\170\000\163\000\
\\200\000\199\000\004\000\201\000\
\\193\000\029\000\004\000\004\000\
\\004\000\017\000\014\000\004\000\
\\004\000\006\000\004\000\038\000\
\\081\001\026\000\080\001\115\000\
\\128\000\235\000\076\001\112\000\
\\250\000\249\000\252\000\113\000\
\\074\001\075\001\107\000\017\000\
\\044\000\126\000\002\000\026\000\
\\088\000\058\001\039\000\061\001\
\\063\001\062\001\026\000\140\000\
\\026\000\039\001\038\001\227\000\
\\237\000\236\000\043\001\044\001\
\\045\001\035\001\033\001\228\000\
\\229\000\187\000\186\000\108\000\
\\109\000\048\000\081\000\051\000\
\\052\000\049\000\162\000\216\000\
\\082\000\205\000\168\000\207\000\
\\209\000\037\000\220\000\211\000\
\\210\000\026\001\114\000\024\000\
\\129\000\018\000\017\000\070\001\
\\012\001\049\001\050\001\120\000\
\\121\000\044\000\092\000\063\000\
\\041\001\040\001\196\000\197\000\
\\005\000\004\000\195\000\194\000\
\\006\000\038\000\006\000\038\000\
\\218\000\212\000\096\000\218\000\
\\214\000\038\000\024\000\085\001\
\\001\001\248\000\051\001\124\000\
\\048\001\002\000\042\001\165\000\
\\053\000\172\000\217\000\222\000\
\\206\000\110\000\038\000\208\000\
\\221\000\215\000\084\001\122\000\
\\076\000\046\000\180\000\213\000\
\\218\000\056\001\219\000\000\000"
val gotoT =
"\
\\007\000\183\001\015\000\002\000\016\000\001\000\000\000\
\\000\000\
\\015\000\002\000\016\000\015\000\000\000\
\\002\000\019\000\004\000\018\000\018\000\017\000\019\000\016\000\000\000\
\\008\000\029\000\017\000\028\000\051\000\027\000\000\000\
\\001\000\041\000\055\000\040\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\080\000\052\000\000\000\
\\002\000\056\000\000\000\
\\002\000\057\000\000\000\
\\002\000\058\000\000\000\
\\002\000\059\000\000\000\
\\002\000\061\000\020\000\060\000\000\000\
\\001\000\062\000\000\000\
\\001\000\063\000\000\000\
\\002\000\065\000\003\000\064\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\022\000\068\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\071\000\000\000\
\\000\000\
\\000\000\
\\054\000\072\000\000\000\
\\000\000\
\\001\000\041\000\063\000\075\000\065\000\074\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\006\000\082\000\000\000\
\\068\000\086\000\000\000\
\\000\000\
\\064\000\089\000\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\055\000\092\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\002\000\097\000\050\000\096\000\072\000\095\000\073\000\094\000\
\\074\000\093\000\000\000\
\\034\000\102\000\035\000\101\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\105\000\000\000\
\\001\000\106\000\000\000\
\\002\000\107\000\000\000\
\\000\000\
\\081\000\109\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\116\000\004\000\115\000\021\000\114\000\048\000\113\000\000\000\
\\011\000\118\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\133\000\023\000\132\000\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\001\000\041\000\055\000\153\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\085\000\152\000\086\000\151\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\063\000\075\000\065\000\160\000\000\000\
\\001\000\041\000\060\000\161\000\061\000\034\000\062\000\033\000\
\\063\000\032\000\000\000\
\\001\000\041\000\060\000\162\000\061\000\034\000\062\000\033\000\
\\063\000\032\000\000\000\
\\001\000\041\000\060\000\163\000\061\000\034\000\062\000\033\000\
\\063\000\032\000\000\000\
\\001\000\041\000\057\000\164\000\058\000\037\000\059\000\036\000\
\\060\000\035\000\061\000\034\000\062\000\033\000\063\000\032\000\000\000\
\\001\000\041\000\057\000\165\000\058\000\037\000\059\000\036\000\
\\060\000\035\000\061\000\034\000\062\000\033\000\063\000\032\000\000\000\
\\001\000\041\000\057\000\166\000\058\000\037\000\059\000\036\000\
\\060\000\035\000\061\000\034\000\062\000\033\000\063\000\032\000\000\000\
\\001\000\041\000\055\000\167\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\097\000\072\000\171\000\073\000\094\000\074\000\093\000\
\\076\000\170\000\077\000\169\000\000\000\
\\066\000\172\000\000\000\
\\000\000\
\\067\000\174\000\000\000\
\\066\000\176\000\000\000\
\\000\000\
\\002\000\097\000\073\000\178\000\074\000\093\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\097\000\073\000\182\000\074\000\093\000\000\000\
\\002\000\097\000\072\000\184\000\073\000\094\000\074\000\093\000\
\\075\000\183\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\097\000\050\000\189\000\072\000\095\000\073\000\094\000\
\\074\000\093\000\000\000\
\\000\000\
\\000\000\
\\013\000\192\000\000\000\
\\047\000\194\000\000\000\
\\069\000\198\000\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\002\000\205\000\000\000\
\\069\000\207\000\070\000\197\000\071\000\196\000\082\000\206\000\000\000\
\\069\000\208\000\070\000\197\000\071\000\196\000\000\000\
\\002\000\116\000\004\000\115\000\021\000\209\000\048\000\113\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\116\000\004\000\212\000\049\000\211\000\000\000\
\\013\000\214\000\000\000\
\\000\000\
\\078\000\217\000\079\000\216\000\000\000\
\\001\000\041\000\055\000\219\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\002\000\133\000\038\000\220\000\039\000\122\000\000\000\
\\000\000\
\\087\000\221\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\133\000\038\000\227\000\039\000\122\000\000\000\
\\002\000\133\000\023\000\229\000\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\036\000\228\000\038\000\123\000\
\\039\000\122\000\000\000\
\\002\000\133\000\023\000\233\000\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\036\000\232\000\037\000\231\000\
\\038\000\123\000\039\000\122\000\000\000\
\\032\000\235\000\033\000\234\000\000\000\
\\000\000\
\\002\000\133\000\031\000\239\000\038\000\123\000\039\000\122\000\000\000\
\\000\000\
\\002\000\133\000\023\000\241\000\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\030\000\242\000\031\000\124\000\038\000\123\000\
\\039\000\122\000\000\000\
\\001\000\041\000\055\000\153\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\085\000\152\000\086\000\243\000\000\000\
\\015\000\002\000\016\000\244\000\000\000\
\\002\000\133\000\029\000\245\000\030\000\125\000\031\000\124\000\
\\038\000\123\000\039\000\122\000\000\000\
\\002\000\116\000\004\000\115\000\048\000\246\000\000\000\
\\002\000\133\000\027\000\247\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\055\000\251\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\085\000\152\000\086\000\250\000\000\000\
\\000\000\
\\001\000\041\000\055\000\253\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\000\000\
\\054\000\254\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\058\000\007\001\059\000\036\000\060\000\035\000\
\\061\000\034\000\062\000\033\000\063\000\032\000\000\000\
\\002\000\097\000\050\000\008\001\072\000\095\000\073\000\094\000\
\\074\000\093\000\000\000\
\\002\000\097\000\050\000\009\001\072\000\095\000\073\000\094\000\
\\074\000\093\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\034\000\102\000\035\000\014\001\000\000\
\\000\000\
\\001\000\041\000\055\000\016\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\001\000\041\000\055\000\017\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\000\000\
\\012\000\019\001\069\000\018\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\069\000\023\001\070\000\197\000\071\000\196\000\000\000\
\\069\000\024\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\069\000\026\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\083\000\027\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\133\000\023\000\030\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\052\000\034\001\053\000\033\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\011\000\038\001\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\055\000\039\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\002\000\133\000\030\000\040\001\031\000\124\000\038\000\123\000\
\\039\000\122\000\000\000\
\\002\000\133\000\030\000\041\001\031\000\124\000\038\000\123\000\
\\039\000\122\000\000\000\
\\002\000\133\000\027\000\042\001\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\025\000\043\001\026\000\129\000\027\000\128\000\
\\028\000\127\000\029\000\126\000\030\000\125\000\031\000\124\000\
\\038\000\123\000\039\000\122\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\055\000\153\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\085\000\152\000\086\000\060\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\055\000\063\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\009\000\064\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\097\000\072\000\171\000\073\000\094\000\074\000\093\000\
\\076\000\066\001\000\000\
\\069\000\067\001\070\000\197\000\071\000\196\000\000\000\
\\066\000\068\001\000\000\
\\001\000\041\000\055\000\069\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\067\000\070\001\000\000\
\\069\000\071\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\097\000\072\000\073\001\073\000\094\000\074\000\093\000\
\\075\000\072\001\000\000\
\\002\000\097\000\072\000\074\001\073\000\094\000\074\000\093\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\014\000\077\001\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\055\000\080\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\070\000\197\000\071\000\081\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\084\000\087\001\000\000\
\\000\000\
\\069\000\207\000\070\000\197\000\071\000\196\000\082\000\089\001\000\000\
\\069\000\090\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\000\000\
\\002\000\116\000\004\000\212\000\049\000\091\001\000\000\
\\000\000\
\\052\000\034\001\053\000\092\001\000\000\
\\010\000\093\001\000\000\
\\078\000\217\000\079\000\097\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\133\000\023\000\100\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\036\000\099\001\038\000\123\000\
\\039\000\122\000\000\000\
\\000\000\
\\000\000\
\\032\000\235\000\033\000\101\001\000\000\
\\002\000\133\000\023\000\102\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\023\000\103\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\023\000\104\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\001\000\041\000\055\000\105\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\002\000\106\001\000\000\
\\002\000\133\000\023\000\107\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\023\000\108\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\028\000\109\001\029\000\126\000\030\000\125\000\
\\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\023\000\110\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\115\001\040\000\114\001\041\000\113\001\042\000\112\001\
\\045\000\111\001\000\000\
\\000\000\
\\069\000\122\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\008\000\124\001\051\000\027\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\001\000\041\000\055\000\128\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\046\000\129\001\000\000\
\\000\000\
\\002\000\097\000\072\000\131\001\073\000\094\000\074\000\093\000\000\000\
\\069\000\132\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\069\000\135\001\070\000\197\000\071\000\196\000\000\000\
\\000\000\
\\069\000\136\001\070\000\197\000\071\000\196\000\000\000\
\\083\000\137\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\115\001\042\000\148\001\045\000\111\001\000\000\
\\002\000\115\001\042\000\151\001\044\000\150\001\045\000\111\001\000\000\
\\000\000\
\\000\000\
\\002\000\115\001\045\000\152\001\000\000\
\\000\000\
\\001\000\041\000\055\000\153\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\085\000\155\001\000\000\
\\000\000\
\\001\000\041\000\058\000\156\001\059\000\036\000\060\000\035\000\
\\061\000\034\000\062\000\033\000\063\000\032\000\000\000\
\\001\000\041\000\055\000\157\001\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\046\000\158\001\000\000\
\\000\000\
\\014\000\159\001\000\000\
\\046\000\160\001\000\000\
\\000\000\
\\000\000\
\\084\000\162\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\133\000\025\000\163\001\026\000\129\000\027\000\128\000\
\\028\000\127\000\029\000\126\000\030\000\125\000\031\000\124\000\
\\038\000\123\000\039\000\122\000\000\000\
\\002\000\133\000\023\000\164\001\024\000\131\000\025\000\130\000\
\\026\000\129\000\027\000\128\000\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\000\000\
\\000\000\
\\002\000\133\000\028\000\165\001\029\000\126\000\030\000\125\000\
\\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\115\001\042\000\166\001\045\000\111\001\000\000\
\\002\000\133\000\027\000\167\001\028\000\127\000\029\000\126\000\
\\030\000\125\000\031\000\124\000\038\000\123\000\039\000\122\000\000\000\
\\002\000\115\001\040\000\168\001\041\000\113\001\042\000\112\001\
\\045\000\111\001\000\000\
\\043\000\169\001\000\000\
\\000\000\
\\000\000\
\\043\000\172\001\000\000\
\\000\000\
\\002\000\115\001\045\000\173\001\000\000\
\\001\000\041\000\055\000\153\000\056\000\039\000\057\000\038\000\
\\058\000\037\000\059\000\036\000\060\000\035\000\061\000\034\000\
\\062\000\033\000\063\000\032\000\085\000\174\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\012\000\175\001\000\000\
\\000\000\
\\002\000\097\000\050\000\177\001\072\000\095\000\073\000\094\000\
\\074\000\093\000\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\002\000\115\001\042\000\180\001\045\000\111\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\000\000\
\\043\000\182\001\000\000\
\\000\000\
\\000\000\
\\000\000\
\"
val numstates = 440
val numrules = 222
val s = ref "" and index = ref 0
val string_to_int = fn () => 
let val i = !index
in index := i+2; Char.ord(String.sub(!s,i)) + Char.ord(String.sub(!s,i+1)) * 256
end
val string_to_list = fn s' =>
    let val len = String.size s'
        fun f () =
           if !index < len then string_to_int() :: f()
           else nil
   in index := 0; s := s'; f ()
   end
val string_to_pairlist = fn (conv_key,conv_entry) =>
     let fun f () =
         case string_to_int()
         of 0 => EMPTY
          | n => PAIR(conv_key (n-1),conv_entry (string_to_int()),f())
     in f
     end
val string_to_pairlist_default = fn (conv_key,conv_entry) =>
    let val conv_row = string_to_pairlist(conv_key,conv_entry)
    in fn () =>
       let val default = conv_entry(string_to_int())
           val row = conv_row()
       in (row,default)
       end
   end
val string_to_table = fn (convert_row,s') =>
    let val len = String.size s'
        fun f ()=
           if !index < len then convert_row() :: f()
           else nil
     in (s := s'; index := 0; f ())
     end
local
  val memo = Array.array(numstates+numrules,ERROR)
  val _ =let fun g i=(Array.update(memo,i,REDUCE(i-numstates)); g(i+1))
       fun f i =
            if i=numstates then g i
            else (Array.update(memo,i,SHIFT (STATE i)); f (i+1))
          in f 0 handle General.Subscript => ()
          end
in
val entry_to_action = fn 0 => ACCEPT | 1 => ERROR | j => Array.sub(memo,(j-2))
end
val gotoT=Array.fromList(string_to_table(string_to_pairlist(NT,STATE),gotoT))
val actionRows=string_to_table(string_to_pairlist_default(T,entry_to_action),actionRows)
val actionRowNumbers = string_to_list actionRowNumbers
val actionT = let val actionRowLookUp=
let val a=Array.fromList(actionRows) in fn i=>Array.sub(a,i) end
in Array.fromList(List.map actionRowLookUp actionRowNumbers)
end
in LrTable.mkLrTable {actions=actionT,gotos=gotoT,numRules=numrules,
numStates=numstates,initialState=STATE 0}
end
end
local open Header in
type pos = int
type arg =  ( pos * pos -> string -> unit ) * ( pos -> pos -> Location.location ) * ( pos -> pos -> Sdml.exp -> Sdml.locexp ) 
structure MlyValue = 
struct
datatype svalue = VOID | ntVOID of unit ->  unit
 | CHAR of unit ->  (string) | STRING of unit ->  (string)
 | REAL of unit ->  (string) | INT of unit ->  (string)
 | TYVAR of unit ->  (string) | ID of unit ->  (string)
 | ctxanno of unit ->  (ParseLib.env -> annotation)
 | annotationtypelist of unit ->  (ParseLib.env -> ParseLib.env*annotype list)
 | annotationtype of unit ->  (ParseLib.env -> ParseLib.env*annotype)
 | indexpredspec of unit ->  (ParseLib.env -> { domain:X.sort }  list)
 | indexfunctionspec of unit ->  (ParseLib.env -> { domain:X.sort,range:X.sort,complement:IndexSym.sym option }  list)
 | indexfunctioncomponent of unit ->  (ParseLib.env -> { domain:X.sort,range:X.sort,complement:IndexSym.sym option } )
 | complement of unit ->  (ParseLib.env -> IndexSym.sym option)
 | primdec of unit ->  (ParseLib.env -> ParseLib.env)
 | datasortpairs of unit ->  ( ( string * string )  list)
 | datasortpair of unit ->  (string*string)
 | X_explist of unit ->  (ParseLib.env -> X.exp)
 | X_explist0 of unit ->  ( ( ParseLib.env -> X.exp )  list)
 | X_exp_2c of unit ->  ( ( ParseLib.env -> X.exp )  list)
 | X_aexp of unit ->  (ParseLib.env -> X.exp)
 | X_appexp of unit ->  (ParseLib.env ->  ( X.exp, IndexSym.sym )  fixitem list)
 | X_exp of unit ->  (ParseLib.env -> X.exp)
 | sprodel of unit ->  (ParseLib.env -> X.sort list)
 | sort0 of unit ->  (ParseLib.env -> X.sort)
 | sort of unit ->  (ParseLib.env -> X.sort)
 | indexrefinement of unit ->  (ParseLib.env -> X.record)
 | commatyvars of unit ->  (string list)
 | commaids of unit ->  (string list)
 | texpl of unit ->  (ParseLib.env ->  ( ParseLib.env * texp list ) )
 | dashalltail of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | atomictexp of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | texpZ of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | texpY of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | texpU of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | texpE of unit ->  (ParseLib.env ->  ( ParseLib.env * texp list ) )
 | texpD of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | texpC of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | texpI of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | texp of unit ->  (ParseLib.env ->  ( ParseLib.env * texp ) )
 | tyvars of unit ->  (string list)
 | tyvarvarianceseq of unit ->  ( ( string * Sdml.Variance.t )  list)
 | tyvarvariance of unit ->  (string*Sdml.Variance.t)
 | tyvarseq of unit ->  (string list)
 | proposition of unit ->  (ParseLib.env -> X.constraint)
 | ids of unit ->  (string list) | idl of unit ->  (string list)
 | stringopt of unit ->  (string option)
 | stringseq of unit ->  (string)
 | atpattern of unit ->  (ParseLib.env -> ParseLib.env*pattern)
 | patternlz of unit ->  (ParseLib.env -> ParseLib.env*pattern list)
 | patternl of unit ->  (ParseLib.env -> ParseLib.env*pattern list)
 | pattern of unit ->  (ParseLib.env -> ParseLib.env*pattern)
 | arm of unit ->  (ParseLib.env -> arm)
 | arms of unit ->  ( ( ParseLib.env -> arm )  list)
 | aexp of unit ->  (ParseLib.env -> locexp)
 | app_exp of unit ->  (ParseLib.env ->  ( locexp, PV.sym )  fixitem list)
 | exp_list of unit ->  ( ( ParseLib.env -> locexp )  list)
 | exp_2c of unit ->  ( ( ParseLib.env -> locexp )  list)
 | record_component_list of unit ->  (ParseLib.env -> ParseLib.env* ( texp list ) )
 | record_component of unit ->  (ParseLib.env -> ParseLib.env*texp)
 | recordexp_component_list of unit ->  (ParseLib.env -> locexp list)
 | recordexp_component of unit ->  (ParseLib.env -> locexp)
 | expZ of unit ->  (ParseLib.env -> locexp)
 | expS of unit ->  (ParseLib.env -> locexp)
 | expR of unit ->  (ParseLib.env -> locexp)
 | expI of unit ->  (ParseLib.env -> locexp)
 | expD of unit ->  (ParseLib.env -> locexp)
 | expC of unit ->  (ParseLib.env -> locexp)
 | expB of unit ->  (ParseLib.env -> locexp)
 | expA of unit ->  (ParseLib.env -> locexp)
 | exp of unit ->  (ParseLib.env -> locexp)
 | colonoranticolon of unit ->  (Sdml.annotation -> Dectype.dectype)
 | fdef of unit ->  (ParseLib.env -> locexp)
 | fdec of unit ->  (ParseLib.env -> ParseLib.env*locdec)
 | valtypedec of unit ->  (ParseLib.env -> ParseLib.env*locdec)
 | valdec of unit ->  (ParseLib.env -> ParseLib.env*locdec list)
 | synonymtypbind of unit ->  (ParseLib.env -> ParseLib.env*decs)
 | decs of unit ->  (ParseLib.env ->  ( ParseLib.env * decs ) )
 | dec of unit ->  (ParseLib.env ->  ( ParseLib.env * decs ) )
 | defaultindexspec of unit ->  (ParseLib.env -> X.exp option)
 | indexspec of unit ->  (ParseLib.env -> ParseLib.env*X.Sorting.t)
 | indexrecordspec of unit ->  (ParseLib.env -> ParseLib.env* ( X.fieldname * X.Sorting.spec )  list)
 | nativename of unit ->  (string option)
 | variancesymbol of unit ->  (Sdml.Variance.t)
 | AND_typbind_opt of unit ->  ( ( TC.sym * (ParseLib.env -> (string * TV.sym) list * texp) )  list)
 | typbind of unit ->  ( ( TC.sym * (ParseLib.env -> (string * TV.sym) list * texp) )  list)
 | program of unit ->  (ParseLib.env*decs -> ParseLib.env*program)
 | in_or_notin of unit ->  (Sdml.testsubtype_sense)
 | optionalsemicolon of unit ->  (unit) | idw of unit ->  (string)
 | idcon of unit ->  (string) | id of unit ->  (string)
 | tcname of unit ->  (string)
end
type svalue = MlyValue.svalue
type result = ParseLib.env*decs -> ParseLib.env*program
end
structure EC=
struct
open LrTable
infix 5 $$
fun x $$ y = y::x
val is_keyword =
fn _ => false
val preferred_change : (term list * term list) list = 
nil
val noShift = 
fn (T 0) => true | _ => false
val showTerminal =
fn (T 0) => "EOF"
  | (T 1) => "ID"
  | (T 2) => "TYVAR"
  | (T 3) => "INT"
  | (T 4) => "REAL"
  | (T 5) => "STRING"
  | (T 6) => "CHAR"
  | (T 7) => "AND"
  | (T 8) => "ANDALSO"
  | (T 9) => "AS"
  | (T 10) => "CASE"
  | (T 11) => "DATACON"
  | (T 12) => "DATASORT"
  | (T 13) => "DATATYPE"
  | (T 14) => "DO"
  | (T 15) => "ELSE"
  | (T 16) => "END"
  | (T 17) => "FN"
  | (T 18) => "FUN"
  | (T 19) => "HANDLE"
  | (T 20) => "IF"
  | (T 21) => "IN"
  | (T 22) => "INDEXCONSTANT"
  | (T 23) => "INDEXFUN"
  | (T 24) => "INDEXPRED"
  | (T 25) => "INDEXSORT"
  | (T 26) => "LET"
  | (T 27) => "LETHINT"
  | (T 28) => "LOCAL"
  | (T 29) => "NOT"
  | (T 30) => "OF"
  | (T 31) => "OP"
  | (T 32) => "ORELSE"
  | (T 33) => "PRIMITIVE"
  | (T 34) => "RAISE"
  | (T 35) => "REC"
  | (T 36) => "TESTSUBTYPE"
  | (T 37) => "THEN"
  | (T 38) => "TRY"
  | (T 39) => "TYPE"
  | (T 40) => "UNIT"
  | (T 41) => "VAL"
  | (T 42) => "WHERE"
  | (T 43) => "WITH"
  | (T 44) => "WITHTYPE"
  | (T 45) => "ANTICOLON"
  | (T 46) => "APOSTROPHE"
  | (T 47) => "ARROW"
  | (T 48) => "ASTERISK"
  | (T 49) => "BAR"
  | (T 50) => "COLON"
  | (T 51) => "COMMA"
  | (T 52) => "DARROW"
  | (T 53) => "DBLCOLON"
  | (T 54) => "DBLCOMMA"
  | (T 55) => "DQUESTION"
  | (T 56) => "EQUALOP"
  | (T 57) => "HASH"
  | (T 58) => "LBRACE"
  | (T 59) => "RBRACE"
  | (T 60) => "LBRACK"
  | (T 61) => "RBRACK"
  | (T 62) => "LPAREN"
  | (T 63) => "RPAREN"
  | (T 64) => "MINUS"
  | (T 65) => "PLUS"
  | (T 66) => "SEMICOLON"
  | (T 67) => "TURNSTILE"
  | (T 68) => "WILD"
  | (T 69) => "SOME"
  | (T 70) => "PERIOD"
  | (T 71) => "LEFTANNO"
  | (T 72) => "TOP"
  | (T 73) => "BOT"
  | (T 74) => "AMP"
  | (T 75) => "SLASH"
  | (T 76) => "DBLAMP"
  | (T 77) => "DBLSLASH"
  | (T 78) => "DASHALL"
  | (T 79) => "DASHEXISTS"
  | _ => "bogus-term"
local open Header in
val errtermvalue=
fn _ => MlyValue.VOID
end
val terms : term list = nil
 $$ (T 79) $$ (T 78) $$ (T 77) $$ (T 76) $$ (T 75) $$ (T 74) $$ (T 73)
 $$ (T 72) $$ (T 71) $$ (T 70) $$ (T 69) $$ (T 68) $$ (T 67) $$ (T 66)
 $$ (T 65) $$ (T 64) $$ (T 63) $$ (T 62) $$ (T 61) $$ (T 60) $$ (T 59)
 $$ (T 58) $$ (T 57) $$ (T 56) $$ (T 55) $$ (T 54) $$ (T 53) $$ (T 52)
 $$ (T 51) $$ (T 50) $$ (T 49) $$ (T 48) $$ (T 47) $$ (T 46) $$ (T 45)
 $$ (T 44) $$ (T 43) $$ (T 42) $$ (T 41) $$ (T 40) $$ (T 39) $$ (T 38)
 $$ (T 37) $$ (T 36) $$ (T 35) $$ (T 34) $$ (T 33) $$ (T 32) $$ (T 31)
 $$ (T 30) $$ (T 29) $$ (T 28) $$ (T 27) $$ (T 26) $$ (T 25) $$ (T 24)
 $$ (T 23) $$ (T 22) $$ (T 21) $$ (T 20) $$ (T 19) $$ (T 18) $$ (T 17)
 $$ (T 16) $$ (T 15) $$ (T 14) $$ (T 13) $$ (T 12) $$ (T 11) $$ (T 10)
 $$ (T 9) $$ (T 8) $$ (T 7) $$ (T 0)end
structure Actions =
struct 
exception mlyAction of int
local open Header in
val actions = 
fn (i392,defaultPos,stack,
    (argument):arg) =>
case (i392,stack)
of  ( 0, ( ( _, ( MlyValue.decs decs1, (decsleft as decs1left), (
decsright as decs1right))) :: rest671)) => let val  result = 
MlyValue.program (fn _ => let val  (decs as decs1) = decs1 ()
 in (
decslevel := 0; (
                                 fn (env, library_decs) =>
                                   let val _ = decslevel := 0
                                       val (env, decs') = decs env
                                       val trailerexp = (#3(argument)) decsright decsright (Tuple [])
                                       val locexp = (#3(argument)) decsleft decsright (Let (library_decs @ decs', trailerexp))
                                   in
                                         (env, Program (ParseLib.get_libinfo env,
                                                        [],
                                                        locexp))
                                   end)
)
end)
 in ( LrTable.NT 6, ( result, decs1left, decs1right), rest671)
end
|  ( 1, ( ( _, ( _, SEMICOLON1left, SEMICOLON1right)) :: rest671)) =>
 let val  result = MlyValue.optionalsemicolon (fn _ => (()))
 in ( LrTable.NT 4, ( result, SEMICOLON1left, SEMICOLON1right), 
rest671)
end
|  ( 2, ( rest671)) => let val  result = MlyValue.optionalsemicolon
 (fn _ => (()))
 in ( LrTable.NT 4, ( result, defaultPos, defaultPos), rest671)
end
|  ( 3, ( ( _, ( _, IN1left, IN1right)) :: rest671)) => let val  
result = MlyValue.in_or_notin (fn _ => (IsSubtype))
 in ( LrTable.NT 5, ( result, IN1left, IN1right), rest671)
end
|  ( 4, ( ( _, ( _, _, IN1right)) :: ( _, ( _, NOT1left, _)) :: 
rest671)) => let val  result = MlyValue.in_or_notin (fn _ => (
IsNotSubtype))
 in ( LrTable.NT 5, ( result, NOT1left, IN1right), rest671)
end
|  ( 5, ( ( _, ( _, EQUALOP1left, EQUALOP1right)) :: rest671)) => let
 val  result = MlyValue.in_or_notin (fn _ => (MutualSubtypes))
 in ( LrTable.NT 5, ( result, EQUALOP1left, EQUALOP1right), rest671)

end
|  ( 6, ( ( _, ( MlyValue.X_exp X_exp1, _, X_exp1right)) :: ( _, ( _, 
EQUALOP1left, _)) :: rest671)) => let val  result = 
MlyValue.defaultindexspec (fn _ => let val  (X_exp as X_exp1) = X_exp1
 ()
 in (fn env => SOME (X_exp env))
end)
 in ( LrTable.NT 13, ( result, EQUALOP1left, X_exp1right), rest671)

end
|  ( 7, ( rest671)) => let val  result = MlyValue.defaultindexspec (fn
 _ => (fn env => NONE))
 in ( LrTable.NT 13, ( result, defaultPos, defaultPos), rest671)
end
|  ( 8, ( ( _, ( MlyValue.indexrecordspec indexrecordspec1, _, 
indexrecordspec1right)) :: ( _, ( MlyValue.defaultindexspec 
defaultindexspec1, _, _)) :: ( _, ( MlyValue.sort sort1, _, _)) :: _
 :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: rest671)) => let val  
result = MlyValue.indexrecordspec (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (sort as sort1) = sort1 ()
 val  (defaultindexspec as defaultindexspec1) = defaultindexspec1 ()
 val  (indexrecordspec as indexrecordspec1) = indexrecordspec1 ()
 in (
fn env =>
              let val fld = IndexFieldName.fresh ID
                  val env = ParseLib.extend_fields env [(ID, (fld, ()))]
                  val (env, rest) = indexrecordspec env
              in (env, (fld, (sort env, defaultindexspec env)) :: rest)
              end
            
)
end)
 in ( LrTable.NT 11, ( result, ID1left, indexrecordspec1right), 
rest671)
end
|  ( 9, ( rest671)) => let val  result = MlyValue.indexrecordspec (fn
 _ => (fn env => (env, [])))
 in ( LrTable.NT 11, ( result, defaultPos, defaultPos), rest671)
end
|  ( 10, ( ( _, ( MlyValue.indexrecordspec indexrecordspec1, _, 
indexrecordspec1right)) :: ( _, ( _, WITH1left, _)) :: rest671)) =>
 let val  result = MlyValue.indexspec (fn _ => let val  (
indexrecordspec as indexrecordspec1) = indexrecordspec1 ()
 in (
fn env => let val (env, irs) = indexrecordspec env 
                                   in
                                     (env, X.Sorting.Fields irs)
                                   end
)
end)
 in ( LrTable.NT 12, ( result, WITH1left, indexrecordspec1right), 
rest671)
end
|  ( 11, ( ( _, ( MlyValue.defaultindexspec defaultindexspec1, _, 
defaultindexspec1right)) :: ( _, ( MlyValue.sort sort1, _, _)) :: ( _,
 ( _, WITH1left, _)) :: rest671)) => let val  result = 
MlyValue.indexspec (fn _ => let val  (sort as sort1) = sort1 ()
 val  (defaultindexspec as defaultindexspec1) = defaultindexspec1 ()
 in (
fn env => (env, X.Sorting.Nameless (sort env, defaultindexspec env)))

end)
 in ( LrTable.NT 12, ( result, WITH1left, defaultindexspec1right), 
rest671)
end
|  ( 12, ( rest671)) => let val  result = MlyValue.indexspec (fn _ =>
 (fn env => (env, X.Sorting.None)))
 in ( LrTable.NT 12, ( result, defaultPos, defaultPos), rest671)
end
|  ( 13, ( ( _, ( MlyValue.AND_typbind_opt AND_typbind_opt1, _, 
AND_typbind_opt1right)) :: ( _, ( MlyValue.texp texp1, _, _)) :: _ :: 
( _, ( MlyValue.tcname tcname1, _, _)) :: ( _, ( MlyValue.tyvarseq 
tyvarseq1, tyvarseq1left, _)) :: rest671)) => let val  result = 
MlyValue.typbind (fn _ => let val  (tyvarseq as tyvarseq1) = tyvarseq1
 ()
 val  (tcname as tcname1) = tcname1 ()
 val  (texp as texp1) = texp1 ()
 val  (AND_typbind_opt as AND_typbind_opt1) = AND_typbind_opt1 ()
 in (
let val tyvar_names = tyvarseq : string list
                                     val tc = TC.fresh tcname
                                 in
                                     (tc,
                                      fn env =>
                                          let val tvbindings = ListPair.zip (tyvar_names, List.map TV.fresh tyvar_names)
                                              val withTVs = ParseLib.Tyvar.extend env tvbindings
                                              val (_, parsed_texp) = texp withTVs
                                          in
                                              (tvbindings, parsed_texp)
                                          end)
                                     ::
                                     AND_typbind_opt
                                 end
)
end)
 in ( LrTable.NT 7, ( result, tyvarseq1left, AND_typbind_opt1right), 
rest671)
end
|  ( 14, ( ( _, ( MlyValue.typbind typbind1, _, typbind1right)) :: ( _
, ( _, AND1left, _)) :: rest671)) => let val  result = 
MlyValue.AND_typbind_opt (fn _ => let val  (typbind as typbind1) = 
typbind1 ()
 in (typbind)
end)
 in ( LrTable.NT 8, ( result, AND1left, typbind1right), rest671)
end
|  ( 15, ( rest671)) => let val  result = MlyValue.AND_typbind_opt (fn
 _ => ([]))
 in ( LrTable.NT 8, ( result, defaultPos, defaultPos), rest671)
end
|  ( 16, ( ( _, ( MlyValue.typbind typbind1, (typbindleft as 
typbind1left), (typbindright as typbind1right))) :: rest671)) => let
 val  result = MlyValue.synonymtypbind (fn _ => let val  (typbind as 
typbind1) = typbind1 ()
 in (
fn env =>
                                        buildSynonym env typbind ((#2(argument)) typbindleft typbindright)
)
end)
 in ( LrTable.NT 16, ( result, typbind1left, typbind1right), rest671)

end
|  ( 17, ( ( _, ( MlyValue.STRING STRING1, _, STRING1right)) :: ( _, (
 _, EQUALOP1left, _)) :: rest671)) => let val  result = 
MlyValue.nativename (fn _ => let val  (STRING as STRING1) = STRING1 ()
 in (SOME STRING)
end)
 in ( LrTable.NT 10, ( result, EQUALOP1left, STRING1right), rest671)

end
|  ( 18, ( rest671)) => let val  result = MlyValue.nativename (fn _ =>
 (NONE))
 in ( LrTable.NT 10, ( result, defaultPos, defaultPos), rest671)
end
|  ( 19, ( ( _, ( MlyValue.tyvarvarianceseq tyvarvarianceseq1, _, 
tyvarvarianceseq1right)) :: ( _, ( MlyValue.indexspec indexspec1, _, 
indexspecright)) :: ( _, ( MlyValue.nativename nativename1, _, _)) :: 
( _, ( MlyValue.tcname tcname1, _, _)) :: ( _, ( _, (DATATYPEleft as 
DATATYPE1left), _)) :: rest671)) => let val  result = MlyValue.dec (fn
 _ => let val  (tcname as tcname1) = tcname1 ()
 val  (nativename as nativename1) = nativename1 ()
 val  (indexspec as indexspec1) = indexspec1 ()
 val  (tyvarvarianceseq as tyvarvarianceseq1) = tyvarvarianceseq1 ()
 in (
fn env =>
                          let 
                              val tc = case nativename of
                                                SOME native => TC.sanitary_fresh tcname native
                                              | NONE => TC.fresh tcname
                              val tc = TC.fresh tcname
                              val tvinfos = List.map (fn (tyvar, variance) => Tvinfo (TV.fresh tyvar, variance))
                                                     tyvarvarianceseq
                              val (env, sorting) = indexspec env
                              val env = ParseLib.Type.extend env [(tcname, ParseLib.SimpleType tc)]
                              val typedec = Datatype {tc= tc,
                                                  builtin= Option.isSome nativename,
                                                  params= tvinfos,
                                                  sorting= sorting,
                                                  constructors= []}
                              val dec = Typedec [typedec]
                          in
                               (
                                env
                                ,
                                [((#2(argument)) DATATYPEleft indexspecright,
                                  dec)]
                               )
                          end
)
end)
 in ( LrTable.NT 14, ( result, DATATYPE1left, tyvarvarianceseq1right),
 rest671)
end
|  ( 20, ( ( _, ( MlyValue.nativename nativename1, _, nativename1right
)) :: ( _, ( MlyValue.texp texp1, _, texpright)) :: _ :: ( _, ( 
MlyValue.idcon idcon1, _, _)) :: ( _, ( _, (DATACONleft as 
DATACON1left), _)) :: rest671)) => let val  result = MlyValue.dec (fn
 _ => let val  (idcon as idcon1) = idcon1 ()
 val  (texp as texp1) = texp1 ()
 val  (nativename as nativename1) = nativename1 ()
 in (
fn env =>
                  let val (env, A) = texp env
                      val (env, pv) = case ParseLib.Pvar.lookup_soft env idcon of
                                   SOME (ParseLib.Convar, pv) => (env, pv)
                                 | _ =>
                                       let val pv = case nativename of
                                                         SOME native => PV.sanitary_fresh idcon native
                                                       | NONE => PV.fresh idcon
                                           val _ = ("Constructor declaration -- freshening " ^ idcon ^ " --> " ^ PV.toString pv ^ "\n")
                                           val (env) = ParseLib.Con.extend env (idcon, pv)
                                       in
                                           (env, pv)
                                       end
                  in
                      (env, [((#2(argument)) DATACONleft texpright, Datacon (pv, A))])
                  end
)
end)
 in ( LrTable.NT 14, ( result, DATACON1left, nativename1right), 
rest671)
end
|  ( 21, ( ( _, ( MlyValue.datasortpairs datasortpairs1, _, 
datasortpairs1right)) :: _ :: ( _, ( MlyValue.tcname tcname1, 
tcnameleft, tcnameright)) :: ( _, ( _, DATASORT1left, _)) :: rest671))
 => let val  result = MlyValue.dec (fn _ => let val  (tcname as 
tcname1) = tcname1 ()
 val  (datasortpairs as datasortpairs1) = datasortpairs1 ()
 in (
fn env =>
                       let val tc = ParseLib.Type.lookup_simple_type ((#1(argument))(tcnameleft, tcnameright)) env tcname
                           val env' = ParseLib.process_subsortpairs tc env datasortpairs
                       in
                           (env', [])
                       end
)
end)
 in ( LrTable.NT 14, ( result, DATASORT1left, datasortpairs1right), 
rest671)
end
|  ( 22, ( ( _, ( MlyValue.sort sort1, _, sort1right)) :: _ :: ( _, ( 
MlyValue.id id1, _, _)) :: ( _, ( _, INDEXSORT1left, _)) :: rest671))
 => let val  result = MlyValue.dec (fn _ => let val  (id as id1) = id1
 ()
 val  (sort as sort1) = sort1 ()
 in (
fn env =>
                     let val newSort = IndexSortSym.fresh id
                         val sort' =
                             case sort env of
                                 X.Base sortname =>
                                      X.Base sortname
                               | sort' => sort'
                         val env = ParseLib.extend_is env [(id, (newSort, sort'))]
                     in
                         (env, [])
                     end
)
end)
 in ( LrTable.NT 14, ( result, INDEXSORT1left, sort1right), rest671)

end
|  ( 23, ( ( _, ( MlyValue.indexfunctionspec indexfunctionspec1, _, 
indexfunctionspec1right)) :: ( _, ( MlyValue.indexfunctioncomponent 
indexfunctioncomponent1, _, _)) :: _ :: ( _, ( MlyValue.id id1, _, _))
 :: ( _, ( _, INDEXFUN1left, _)) :: rest671)) => let val  result = 
MlyValue.dec (fn _ => let val  (id as id1) = id1 ()
 val  (indexfunctioncomponent as indexfunctioncomponent1) = 
indexfunctioncomponent1 ()
 val  (indexfunctionspec as indexfunctionspec1) = indexfunctionspec1
 ()
 in (
fn env => let val iv = IndexSym.fresh id
                               val info = (iv, X.IFun (indexfunctioncomponent env :: indexfunctionspec env))
                               val _ = X.addFun info
                               val env' = ParseLib.extend_iv env [(id, info)]
                           in
                               (env', [])
                           end
)
end)
 in ( LrTable.NT 14, ( result, INDEXFUN1left, indexfunctionspec1right)
, rest671)
end
|  ( 24, ( ( _, ( MlyValue.sort sort1, _, sort1right)) :: _ :: ( _, ( 
MlyValue.id id1, _, _)) :: ( _, ( _, INDEXCONSTANT1left, _)) :: 
rest671)) => let val  result = MlyValue.dec (fn _ => let val  (id as 
id1) = id1 ()
 val  (sort as sort1) = sort1 ()
 in (
fn env =>
                         let val iv = IndexSym.fresh id
                             val range = sort env
                             val info = (iv, case id of
                                                             "true" => X.ITrue
                                                           | "false" => X.IFalse
                                                           | "NODIM" => X.INODIM
                                                           | _ => if range = X.Base(X.getDimSort()) then
                                                                      X.IBaseDim
                                                                  else
                                                                      X.INil range)
                             val _ = X.addFun info
                             val env' = ParseLib.extend_iv env [(id, info)]
                         in
                             (env', [])
                         end
)
end)
 in ( LrTable.NT 14, ( result, INDEXCONSTANT1left, sort1right), 
rest671)
end
|  ( 25, ( ( _, ( MlyValue.indexpredspec indexpredspec1, _, 
indexpredspec1right)) :: ( _, ( MlyValue.sort sort1, _, _)) :: _ :: (
 _, ( MlyValue.complement complement1, _, _)) :: ( _, ( MlyValue.id 
id1, _, _)) :: ( _, ( _, INDEXPRED1left, _)) :: rest671)) => let val  
result = MlyValue.dec (fn _ => let val  (id as id1) = id1 ()
 val  (complement as complement1) = complement1 ()
 val  (sort as sort1) = sort1 ()
 val  (indexpredspec as indexpredspec1) = indexpredspec1 ()
 in (
fn env => let val iv = IndexSym.fresh id
                                  val first = {domain= sort env}
                                  val rest = indexpredspec env
                                  val complementaryPred = complement env
                                  val info = (iv, X.IFun (map (fn {domain= domain} => {domain= domain,
                                                                                       range= X.Base (X.getBoolSort()),
                                                                                       complement= complementaryPred})
                                                              (first :: rest)))
                                  val _ = X.addFun info
                                  val env = case complementaryPred of
                                              NONE => env
                                           |  SOME pred => let in case X.getSyminfo pred of
                                                                       SOME (X.IFun xs) =>
                                                                           let val infoC = X.IFun(
                                                                                           map (fn {domain= s1, range= s2, complement= NONE}
                                                                                                   =>
                                                                                                   {domain=s1, range=s2, complement= SOME iv}) xs)
                                                                           in
                                                                           X.addFun (pred, infoC);
                                                                           ParseLib.extend_iv env [(IndexSym.toShortString pred, (pred, infoC))]
                                                                       end
                                                            end
                                  val env = ParseLib.extend_iv env [(id, info)]
                        in
                            (env, [])
                        end
)
end)
 in ( LrTable.NT 14, ( result, INDEXPRED1left, indexpredspec1right), 
rest671)
end
|  ( 26, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.texp texp2, _, 
texp2right)) :: ( _, ( MlyValue.in_or_notin in_or_notin1, _, _)) :: (
 _, ( MlyValue.texp texp1, texp1left, _)) :: ( _, ( _, 
TESTSUBTYPE1left, _)) :: rest671)) => let val  result = MlyValue.dec
 (fn _ => let val  texp1 = texp1 ()
 val  (in_or_notin as in_or_notin1) = in_or_notin1 ()
 val  texp2 = texp2 ()
 in (
fn env => let val (env, A) = texp1 env
                            val sense = in_or_notin
                            val (env, B) = texp2 env
                            val loc = (#2(argument)) texp1left texp2right
                            val d = TestSubtype (sense, (A, B)) 
                        in
                            (env, [(loc, d)])
                        end
)
end)
 in ( LrTable.NT 14, ( result, TESTSUBTYPE1left, END1right), rest671)

end
|  ( 27, ( ( _, ( MlyValue.primdec primdec1, _, primdec1right)) :: ( _
, ( _, PRIMITIVE1left, _)) :: rest671)) => let val  result = 
MlyValue.dec (fn _ => let val  (primdec as primdec1) = primdec1 ()
 in (
fn env => let val env = primdec env
                                               in
                                                   (env, [])
                                               end
)
end)
 in ( LrTable.NT 14, ( result, PRIMITIVE1left, primdec1right), rest671
)
end
|  ( 28, ( ( _, ( MlyValue.synonymtypbind synonymtypbind1, _, 
synonymtypbind1right)) :: ( _, ( _, TYPE1left, _)) :: rest671)) => let
 val  result = MlyValue.dec (fn _ => let val  (synonymtypbind as 
synonymtypbind1) = synonymtypbind1 ()
 in (synonymtypbind)
end)
 in ( LrTable.NT 14, ( result, TYPE1left, synonymtypbind1right), 
rest671)
end
|  ( 29, ( ( _, ( MlyValue.valdec valdec1, _, valdec1right)) :: ( _, (
 _, VAL1left, _)) :: rest671)) => let val  result = MlyValue.dec (fn _
 => let val  (valdec as valdec1) = valdec1 ()
 in (
fn env =>
                                  let val (env, decs) = valdec env
                                  in (env, decs)
                                  end
)
end)
 in ( LrTable.NT 14, ( result, VAL1left, valdec1right), rest671)
end
|  ( 30, ( ( _, ( MlyValue.valtypedec valtypedec1, _, valtypedec1right
)) :: ( _, ( _, VAL1left, _)) :: rest671)) => let val  result = 
MlyValue.dec (fn _ => let val  (valtypedec as valtypedec1) = 
valtypedec1 ()
 in (
fn env =>
                                  let val (env, dec) = valtypedec env
                                  in
                                      (env, [dec])
                                  end
)
end)
 in ( LrTable.NT 14, ( result, VAL1left, valtypedec1right), rest671)

end
|  ( 31, ( ( _, ( MlyValue.fdec fdec1, _, fdec1right)) :: ( _, ( _, 
FUN1left, _)) :: rest671)) => let val  result = MlyValue.dec (fn _ =>
 let val  (fdec as fdec1) = fdec1 ()
 in (
fn env =>
                                       let val (env, d) = fdec env
                                       in
                                           (env, [d])
                                       end
)
end)
 in ( LrTable.NT 14, ( result, FUN1left, fdec1right), rest671)
end
|  ( 32, ( ( _, ( MlyValue.decs decs1, _, decs1right)) :: ( _, ( 
MlyValue.dec dec1, dec1left, _)) :: rest671)) => let val  result = 
MlyValue.decs (fn _ => let val  (dec as dec1) = dec1 ()
 val  (decs as decs1) = decs1 ()
 in (
fn env =>
                                   let val (env, ds) = dec env
                                       val (env, dsl) = decs env
                                   in (env, ds @ dsl)
                                   end
)
end)
 in ( LrTable.NT 15, ( result, dec1left, decs1right), rest671)
end
|  ( 33, ( rest671)) => let val  result = MlyValue.decs (fn _ => (
fn env => (env, [])))
 in ( LrTable.NT 15, ( result, defaultPos, defaultPos), rest671)
end
|  ( 34, ( ( _, ( _, COLON1left, COLON1right)) :: rest671)) => let
 val  result = MlyValue.colonoranticolon (fn _ => (
fn anno =>
                                                   Sdml.Dectype.AGAINST anno
                                              
))
 in ( LrTable.NT 21, ( result, COLON1left, COLON1right), rest671)
end
|  ( 35, ( ( _, ( _, ANTICOLON1left, ANTICOLON1right)) :: rest671)) =>
 let val  result = MlyValue.colonoranticolon (fn _ => (
fn anno =>
                                       let in
                                           case anno of
                                               [Sdml.AnnotationType.Type A] => Sdml.Dectype.TOPLEVEL_NOT  A
                                             | _ => fail ":! used with complex annotation"
                                       end
))
 in ( LrTable.NT 21, ( result, ANTICOLON1left, ANTICOLON1right), 
rest671)
end
|  ( 36, ( ( _, ( MlyValue.annotationtypelist annotationtypelist1, _,
 (annotationtypelistright as annotationtypelist1right))) :: ( _, ( 
MlyValue.colonoranticolon colonoranticolon1, _, _)) :: ( _, ( 
MlyValue.id id1, (idleft as id1left), _)) :: rest671)) => let val  
result = MlyValue.valtypedec (fn _ => let val  (id as id1) = id1 ()
 val  (colonoranticolon as colonoranticolon1) = colonoranticolon1 ()
 val  (annotationtypelist as annotationtypelist1) = 
annotationtypelist1 ()
 in (
fn env =>
                                     let 
                                         val (env, anno) = annotationtypelist env
                                         val (env, pv) =
                                             case ParseLib.Pvar.lookup_soft env id of
                                                 NONE =>
                                                     let val pv = PV.fresh id
                                                     in
                                                         (ParseLib.Pvar.extendOpt env [(id, pv, SOME (Dectype.AGAINST anno),
                                                                                        ParseLib.Neutral)],
                                                          pv)
                                                     end
                                               | SOME (ParseLib.Ordvar (SOME _, ref ParseLib.Neutral), pv) =>
                                                    (print ("Warning: unused type declaration (" ^ PV.toShortString pv
                                                            ^ "), shadowed by new type declaration\n");
                                                     let val pv = PV.fresh id
                                                     in
                                                         (ParseLib.Pvar.extendOpt env [(id, pv, SOME (Dectype.AGAINST anno), ParseLib.Neutral)],
                                                          pv)
                                                     end)
                                               | SOME (ParseLib.Ordvar (_, pvstatus), pv) =>
                                                    (let val pv = PV.fresh id
                                                     in
                                                         (ParseLib.Pvar.extendOpt env [(id, pv, SOME (Dectype.AGAINST anno), ParseLib.Neutral)],
                                                          pv)
                                                     end)
                                               | SOME (ParseLib.Convar, pv) =>
                                                     (print ("Cannot shadow a constructor with a variable (" ^ PV.toShortString pv ^ ")\n");
                                                      raise Option)
                                         
                                         val dectype = colonoranticolon anno
                                     in
                                         (env,
                                            ((#2(argument)) idleft annotationtypelistright,
                                             ValType (pv, dectype))
                                         )
                                     end
)
end)
 in ( LrTable.NT 18, ( result, id1left, annotationtypelist1right), 
rest671)
end
|  ( 37, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) :: _
 :: ( _, ( MlyValue.idw idw1, (idwleft as idw1left), _)) :: rest671))
 => let val  result = MlyValue.valdec (fn _ => let val  (idw as idw1)
 = idw1 ()
 val  (exp as exp1) = exp1 ()
 in (
fn env =>
                                                 let val (envWithThisDec, pv, annoOpt) =
                                                         case ParseLib.Pvar.lookup_soft env idw of
                                                             NONE =>
                                                                let val pv = PV.fresh idw
                                                                    val _ = dprint (fn () => "valdec  " ^ idw ^ ":  -NONE-")
                                                                    val env = ParseLib.Pvar.extendOpt env [(idw, pv, NONE, ParseLib.DefinedVal)]
                                                                in
                                                                    (env, pv, NONE)
                                                                end
                                                           | SOME (ParseLib.Ordvar (annoOpt, pvstatus as ref ParseLib.Neutral), pv) =>
                                                                let 
                                                                    val _ = dprint (fn () => "valdec  " ^ idw ^ ":  ParseLib.Neutral")
                                                                    val _ = pvstatus := ParseLib.DefinedVal
                                                                in
                                                                    (env, pv, annoOpt)
                                                                end
                                                           | SOME (ParseLib.Ordvar (annoOpt, ref ParseLib.DefinedVal), pv) =>
                                                                let val pv = PV.fresh idw
                                                                    val _ = dprint (fn () => "valdec  " ^ idw ^ ":  ParseLib.DefinedVal")
                                                                    val env = ParseLib.Pvar.extendOpt env [(idw, pv, annoOpt, ParseLib.DefinedVal)]
                                                                in
                                                                    (env, pv, annoOpt)
                                                                end
                                                           | SOME (ParseLib.Ordvar (annoOpt, ref ParseLib.DefinedFun), pv) =>
                                                                 (print ("Cannot use `val' to redefine `fun' " ^ PV.toShortString pv ^ "\n");
                                                                  raise Option)
                                                           | SOME (ParseLib.Ordvar (annoOpt, ref ParseLib.FutureFun), pv) =>
                                                                 (print ("Must use `fun' to declare variable " ^ PV.toShortString pv ^ "\n");
                                                                  raise Option)
                                                           | SOME (ParseLib.Convar, pv) =>
                                                                 (print ("Cannot shadow a constructor with a variable (" ^ PV.toShortString pv ^ ")\n");
                                                                  raise Option)

                                                     val loc = (#2(argument)) idwleft expright
                                                     val texpdec = case annoOpt of
                                                                                NONE => []
                                                                              | SOME dectype =>
                                                                                     let in
                                                                                         [(loc, ValType (pv, dectype))]
                                                                                     end
                                                     val expdec = [(loc, Dec (pv, ValKW, exp env))]
                                                 in
                                                     (envWithThisDec,
                                                         texpdec @ expdec
                                                     )
                                                 end
)
end)
 in ( LrTable.NT 17, ( result, idw1left, exp1right), rest671)
end
|  ( 38, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671)) =>
 let val  result = MlyValue.idw (fn _ => let val  (id as id1) = id1 ()
 in (id)
end)
 in ( LrTable.NT 3, ( result, id1left, id1right), rest671)
end
|  ( 39, ( ( _, ( _, WILD1left, WILD1right)) :: rest671)) => let val  
result = MlyValue.idw (fn _ => ("anon_"))
 in ( LrTable.NT 3, ( result, WILD1left, WILD1right), rest671)
end
|  ( 40, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671)) =>
 let val  result = MlyValue.idcon (fn _ => let val  (id as id1) = id1
 ()
 in (id)
end)
 in ( LrTable.NT 2, ( result, id1left, id1right), rest671)
end
|  ( 41, ( ( _, ( _, DBLCOLON1left, DBLCOLON1right)) :: rest671)) =>
 let val  result = MlyValue.idcon (fn _ => ("::"))
 in ( LrTable.NT 2, ( result, DBLCOLON1left, DBLCOLON1right), rest671)

end
|  ( 42, ( ( _, ( MlyValue.fdef fdef1, _, (fdefright as fdef1right)))
 :: ( _, ( MlyValue.id id1, (idleft as id1left), _)) :: rest671)) =>
 let val  result = MlyValue.fdec (fn _ => let val  (id as id1) = id1
 ()
 val  (fdef as fdef1) = fdef1 ()
 in (
fn env =>                                   
                                        let val (envWithFun, pv) =
                                                case ParseLib.Pvar.lookup_soft env id of
                                                    NONE =>
                                                        let val pv = PV.fresh id 
                                                        in
                                                            (ParseLib.Pvar.extendOpt env [(id, pv, NONE, ParseLib.DefinedFun)],
                                                             pv)
                                                        end
                                                  | SOME (ParseLib.Ordvar (annoOpt, pvstatus as ref ParseLib.Neutral), pv) =>
                                                        let val _ = pvstatus := ParseLib.DefinedFun
                                                        in
                                                            (env, pv)
                                                        end
                                                  | SOME (ParseLib.Ordvar (annoOpt, pvstatus as ref ParseLib.FutureFun), pv) =>
                                                        let val _ = pvstatus := ParseLib.DefinedFun
                                                        in
                                                            (env, pv)
                                                        end
                                                  | SOME (ParseLib.Ordvar (annoOpt, ref ParseLib.DefinedFun), pv) =>
                                                        (print ("Cannot shadow `fun' with `fun': variable " ^ PV.toShortString pv ^ "\n");
                                                         raise Option)
                                                  | SOME (ParseLib.Ordvar (annoOpt, ref ParseLib.DefinedVal), pv) =>
                                                        (print ("Cannot shadow `val' with `fun': variable " ^ PV.toShortString pv ^ "\n");
                                                         raise Option)
                                                  | SOME (ParseLib.Convar, pv) =>
                                                        (print ("Cannot shadow a constructor with a variable (" ^ PV.toShortString pv ^ ")\n");
                                                         raise Option)
                                        in
                                            (envWithFun,
                                               ((#2(argument)) idleft fdefright,
                                                Dec(pv, FunKW, fdef envWithFun))
                                            )
                                        end
)
end)
 in ( LrTable.NT 19, ( result, id1left, fdef1right), rest671)
end
|  ( 43, ( ( _, ( MlyValue.fdef fdef1, _, (fdefright as fdef1right)))
 :: ( _, ( MlyValue.idl idl1, (idlleft as idl1left), _)) :: rest671))
 => let val  result = MlyValue.fdef (fn _ => let val  (idl as idl1) = 
idl1 ()
 val  (fdef as fdef1) = fdef1 ()
 in (
fn env =>
                                     let val pvl = List.map PV.fresh idl
                                         val bindings = ListPair.zip (idl, pvl)
                                         val env' = ParseLib.Pvar.extend_DefinedVal env bindings
                                     in (#3(argument)) idlleft fdefright (ParseLib.Pvar.tupleize pvl (fdef env'))
                                     end
)
end)
 in ( LrTable.NT 20, ( result, idl1left, fdef1right), rest671)
end
|  ( 44, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) :: _
 :: ( _, ( MlyValue.idl idl1, (idlleft as idl1left), _)) :: rest671))
 => let val  result = MlyValue.fdef (fn _ => let val  (idl as idl1) = 
idl1 ()
 val  (exp as exp1) = exp1 ()
 in (
fn env => 
                                     let val pvl = List.map PV.fresh idl
                                         val bindings = ListPair.zip (idl, pvl)
                                         val env' = ParseLib.Pvar.extend_DefinedVal env bindings
                                     in (#3(argument)) idlleft expright (ParseLib.Pvar.tupleize pvl (exp env'))
                                     end
)
end)
 in ( LrTable.NT 20, ( result, idl1left, exp1right), rest671)
end
|  ( 45, ( ( _, ( MlyValue.expA expA1, expA1left, expA1right)) :: 
rest671)) => let val  result = MlyValue.exp (fn _ => let val  (expA
 as expA1) = expA1 ()
 in (fn env => expA env)
end)
 in ( LrTable.NT 22, ( result, expA1left, expA1right), rest671)
end
|  ( 46, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) :: _
 :: ( _, ( MlyValue.idl idl1, _, _)) :: ( _, ( _, (FNleft as FN1left),
 _)) :: rest671)) => let val  result = MlyValue.exp (fn _ => let val 
 (idl as idl1) = idl1 ()
 val  (exp as exp1) = exp1 ()
 in (
fn env => 
                                        let val pvl = map PV.fresh idl
                                            val bindings = ListPair.zip (idl, pvl)
                                            val env' = ParseLib.Pvar.extend_DefinedVal env bindings
                                        in (#3(argument)) FNleft expright (ParseLib.Pvar.tupleize pvl (exp env'))
                                        end
)
end)
 in ( LrTable.NT 22, ( result, FN1left, exp1right), rest671)
end
|  ( 47, ( ( _, ( MlyValue.expB expB1, _, (expBright as expB1right)))
 :: _ :: ( _, ( MlyValue.expA expA1, (expAleft as expA1left), _)) :: 
rest671)) => let val  result = MlyValue.expA (fn _ => let val  (expA
 as expA1) = expA1 ()
 val  (expB as expB1) = expB1 ()
 in (
fn env =>
                      let val head = expA env
                          val tail = expB env
                      in
                          case head of
                              (loc, Merge head) => (#3(argument)) expAleft expBright (Merge (head @ [tail]))
                            | head => (#3(argument)) expAleft expBright (Merge [head, tail])
                      end
)
end)
 in ( LrTable.NT 23, ( result, expA1left, expB1right), rest671)
end
|  ( 48, ( ( _, ( MlyValue.expB expB1, expB1left, expB1right)) :: 
rest671)) => let val  result = MlyValue.expA (fn _ => let val  (expB
 as expB1) = expB1 ()
 in (fn env => expB env)
end)
 in ( LrTable.NT 23, ( result, expB1left, expB1right), rest671)
end
|  ( 49, ( ( _, ( MlyValue.expB expB1, _, (expBright as expB1right)))
 :: _ :: ( _, ( MlyValue.texp texp1, _, _)) :: _ :: ( _, ( MlyValue.ID
 ID1, IDleft, IDright)) :: ( _, ( _, WHERE1left, _)) :: rest671)) =>
 let val  result = MlyValue.expB (fn _ => let val  (ID as ID1) = ID1
 ()
 val  (texp as texp1) = texp1 ()
 val  (expB as expB1) = expB1 ()
 in (
fn env =>
                                         let val (_, A) = texp env
                                             val (pvinfo, pv) = ParseLib.Pvar.lookup ((#1(argument))(IDleft, IDright)) env ID
                                             val tail = expB env
                                    in
                                        case pvinfo of
                                            ParseLib.Convar => ((#1(argument))(IDleft, IDright) "constructors forbidden in concrete contexts";
                                                           raise Debug.StdExcept("", ""))
                                          | ParseLib.Ordvar _ =>
                                                let val leftanno = LeftProgramVar (pv, A)
                                                in
                                                    ((#2(argument)) IDleft expBright, Leftanno (leftanno, tail))
                                                end
                                    end
)
end)
 in ( LrTable.NT 24, ( result, WHERE1left, expB1right), rest671)
end
|  ( 50, ( ( _, ( MlyValue.expC expC1, expC1left, expC1right)) :: 
rest671)) => let val  result = MlyValue.expB (fn _ => let val  (expC
 as expC1) = expC1 ()
 in (fn env => expC env)
end)
 in ( LrTable.NT 24, ( result, expC1left, expC1right), rest671)
end
|  ( 51, ( ( _, ( MlyValue.expD expD1, expD1left, expD1right)) :: 
rest671)) => let val  result = MlyValue.expC (fn _ => let val  (expD
 as expD1) = expD1 ()
 in (fn env => expD env)
end)
 in ( LrTable.NT 25, ( result, expD1left, expD1right), rest671)
end
|  ( 52, ( ( _, ( MlyValue.arms arms1, _, (armsright as arms1right)))
 :: _ :: ( _, ( MlyValue.expD expD1, _, _)) :: ( _, ( _, (CASEleft as 
CASE1left), _)) :: rest671)) => let val  result = MlyValue.expC (fn _
 => let val  (expD as expD1) = expD1 ()
 val  (arms as arms1) = arms1 ()
 in (
fn env =>
                                       (#3(argument)) CASEleft armsright (Case(expD env, Basic.mapapply arms env))
                                   
)
end)
 in ( LrTable.NT 25, ( result, CASE1left, arms1right), rest671)
end
|  ( 53, ( ( _, ( MlyValue.expI expI1, expI1left, expI1right)) :: 
rest671)) => let val  result = MlyValue.expD (fn _ => let val  (expI
 as expI1) = expI1 ()
 in (fn env => expI env)
end)
 in ( LrTable.NT 26, ( result, expI1left, expI1right), rest671)
end
|  ( 54, ( ( _, ( MlyValue.expD expD1, _, (expDright as expD1right)))
 :: _ :: ( _, ( MlyValue.expI expI1, (expIleft as expI1left), _)) :: 
rest671)) => let val  result = MlyValue.expD (fn _ => let val  (expI
 as expI1) = expI1 ()
 val  (expD as expD1) = expD1 ()
 in (
fn env => (#3(argument)) expIleft expDright (Let(
                                               [((#2(argument)) expIleft expDright, Dec(PV.fresh "anonSemi", ValKW, expI env))],
                                               expD env))
)
end)
 in ( LrTable.NT 26, ( result, expI1left, expD1right), rest671)
end
|  ( 55, ( ( _, ( MlyValue.expR expR1, expR1left, expR1right)) :: 
rest671)) => let val  result = MlyValue.expI (fn _ => let val  (expR
 as expR1) = expR1 ()
 in (fn env => expR env)
end)
 in ( LrTable.NT 27, ( result, expR1left, expR1right), rest671)
end
|  ( 56, ( ( _, ( MlyValue.expI expI2, _, expI2right)) :: _ :: ( _, ( 
MlyValue.expI expI1, _, _)) :: _ :: ( _, ( MlyValue.expR expR1, _, _))
 :: ( _, ( _, (IFleft as IF1left), _)) :: rest671)) => let val  result
 = MlyValue.expI (fn _ => let val  (expR as expR1) = expR1 ()
 val  expI1 = expI1 ()
 val  expI2 = expI2 ()
 in (
fn env => 
                                    let val {true= true_pv, false= false_pv} = ParseLib.Con.get_bool ((#1(argument))(IFleft,expI2right)) env
                                    in (#3(argument)) IFleft expI2right (Case(expR env,
                                            [Arm(CtorPattern(true_pv,NONE),expI1 env),
                                             Arm(CtorPattern(false_pv,NONE),expI2 env)]))
                                    end
)
end)
 in ( LrTable.NT 27, ( result, IF1left, expI2right), rest671)
end
|  ( 57, ( ( _, ( MlyValue.expS expS1, expS1left, expS1right)) :: 
rest671)) => let val  result = MlyValue.expR (fn _ => let val  (expS
 as expS1) = expS1 ()
 in (fn env => expS env)
end)
 in ( LrTable.NT 28, ( result, expS1left, expS1right), rest671)
end
|  ( 58, ( ( _, ( MlyValue.expS expS2, _, expS2right)) :: ( _, ( _, 
ORELSEleft, ORELSEright)) :: ( _, ( MlyValue.expS expS1, expS1left, _)
) :: rest671)) => let val  result = MlyValue.expR (fn _ => let val  
expS1 = expS1 ()
 val  expS2 = expS2 ()
 in (
fn env =>
                                        let val {true= true_pv, false= false_pv} = ParseLib.Con.get_bool ((#1(argument))(expS1left,expS2right)) env
                                        in (#3(argument)) expS1left expS2right (Case(expS1 env,
                                                [Arm(CtorPattern(true_pv,NONE), (#3(argument)) ORELSEleft ORELSEright (Var true_pv)),
                                                 Arm(CtorPattern(false_pv,NONE), expS2 env)]))
                                        end
)
end)
 in ( LrTable.NT 28, ( result, expS1left, expS2right), rest671)
end
|  ( 59, ( ( _, ( MlyValue.expS expS2, _, expS2right)) :: ( _, ( _, 
ANDALSOleft, ANDALSOright)) :: ( _, ( MlyValue.expS expS1, expS1left,
 _)) :: rest671)) => let val  result = MlyValue.expR (fn _ => let val 
 expS1 = expS1 ()
 val  expS2 = expS2 ()
 in (
fn env => 
                                        let val {true= true_pv, false= false_pv} = ParseLib.Con.get_bool ((#1(argument))(expS1left,expS2right)) env
                                        in (#3(argument)) expS1left expS2right (Case(expS1 env,
                                                [Arm(CtorPattern(true_pv,NONE), expS2 env),
                                                 Arm(CtorPattern(false_pv,NONE), (#3(argument)) ANDALSOleft ANDALSOright (Var false_pv))]))
                                        end
)
end)
 in ( LrTable.NT 28, ( result, expS1left, expS2right), rest671)
end
|  ( 60, ( ( _, ( MlyValue.expS expS1, _, (expSright as expS1right)))
 :: ( _, ( _, (RAISEleft as RAISE1left), _)) :: rest671)) => let val  
result = MlyValue.expR (fn _ => let val  (expS as expS1) = expS1 ()
 in (fn env => (#3(argument)) RAISEleft expSright (Raise (expS env)))

end)
 in ( LrTable.NT 28, ( result, RAISE1left, expS1right), rest671)
end
|  ( 61, ( ( _, ( MlyValue.expZ expZ1, expZ1left, expZ1right)) :: 
rest671)) => let val  result = MlyValue.expS (fn _ => let val  (expZ
 as expZ1) = expZ1 ()
 in (fn env => expZ env)
end)
 in ( LrTable.NT 29, ( result, expZ1left, expZ1right), rest671)
end
|  ( 62, ( ( _, ( MlyValue.ctxanno ctxanno1, _, (ctxannoright as 
ctxanno1right))) :: ( _, ( MlyValue.expZ expZ1, (expZleft as expZ1left
), _)) :: rest671)) => let val  result = MlyValue.expS (fn _ => let
 val  (expZ as expZ1) = expZ1 ()
 val  (ctxanno as ctxanno1) = ctxanno1 ()
 in (
fn env =>
                                                              let val anno = ctxanno env
                                                              in
                                                                  (#3(argument)) expZleft ctxannoright (Anno (expZ env, anno))
                                                              end
)
end)
 in ( LrTable.NT 29, ( result, expZ1left, ctxanno1right), rest671)
end
|  ( 63, ( ( _, ( MlyValue.expZ expZ1, _, (expZright as expZ1right)))
 :: ( _, ( _, (DQUESTIONleft as DQUESTION1left), _)) :: rest671)) =>
 let val  result = MlyValue.expS (fn _ => let val  (expZ as expZ1) = 
expZ1 ()
 in (
fn env => 
                             let val e0 = expZ env
                             in
                                 (#3(argument)) DQUESTIONleft expZright (Spy ((), e0))
                             end
)
end)
 in ( LrTable.NT 29, ( result, DQUESTION1left, expZ1right), rest671)

end
|  ( 64, ( ( _, ( _, _, END1right)) :: ( _, ( MlyValue.exp exp2, _, 
exp2right)) :: _ :: ( _, ( MlyValue.id id1, _, _)) :: _ :: ( _, ( 
MlyValue.exp exp1, exp1left, _)) :: ( _, ( _, TRY1left, _)) :: rest671
)) => let val  result = MlyValue.expS (fn _ => let val  exp1 = exp1 ()
 val  (id as id1) = id1 ()
 val  exp2 = exp2 ()
 in (
fn env =>
                                let val pv = PV.fresh id
                                    val env' = ParseLib.Pvar.extend_DefinedVal env [(id, pv)]
                                in
                                    (#3(argument)) exp1left exp2right (Handle (exp1 env, pv, exp2 env'))
                                end
)
end)
 in ( LrTable.NT 29, ( result, TRY1left, END1right), rest671)
end
|  ( 65, ( ( _, ( MlyValue.app_exp app_exp1, app_exp1left, 
app_exp1right)) :: rest671)) => let val  result = MlyValue.expZ (fn _
 => let val  (app_exp as app_exp1) = app_exp1 ()
 in (fn env => unflatten (app_exp env))
end)
 in ( LrTable.NT 30, ( result, app_exp1left, app_exp1right), rest671)

end
|  ( 66, ( ( _, ( MlyValue.aexp aexp1, (aexpleft as aexp1left), (
aexpright as aexp1right))) :: rest671)) => let val  result = 
MlyValue.app_exp (fn _ => let val  (aexp as aexp1) = aexp1 ()
 in (
fn env =>
                              let val item = aexp env
                              in
                                  [{item= item,
                                          loc=(#2(argument)) aexpleft aexpright, fixity=NONE}]
                              end
)
end)
 in ( LrTable.NT 37, ( result, aexp1left, aexp1right), rest671)
end
|  ( 67, ( ( _, ( MlyValue.id id1, (idleft as id1left), (idright as 
id1right))) :: rest671)) => let val  result = MlyValue.app_exp (fn _
 => let val  (id as id1) = id1 ()
 in (
fn env =>
                                       let 
                                           val _ = mungeEnvForFwdRef env id
                                           val (v,f) = var'n'fix env id ((#1(argument))(idleft,idright))
                                       in
                                            [{item=(#3(argument)) idleft idright (v),
                                              loc=(#2(argument)) idleft idright,
                                              fixity=SOME f}]
                                       end
)
end)
 in ( LrTable.NT 37, ( result, id1left, id1right), rest671)
end
|  ( 68, ( ( _, ( MlyValue.app_exp app_exp1, _, app_exp1right)) :: ( _
, ( MlyValue.aexp aexp1, (aexpleft as aexp1left), aexpright)) :: 
rest671)) => let val  result = MlyValue.app_exp (fn _ => let val  (
aexp as aexp1) = aexp1 ()
 val  (app_exp as app_exp1) = app_exp1 ()
 in (
fn env => 
                            let val item = aexp env
                                val tail = app_exp env
                            in
                                {item= item,
                                 loc= (#2(argument)) aexpleft aexpright, fixity=NONE}
                                :: tail
                            end
)
end)
 in ( LrTable.NT 37, ( result, aexp1left, app_exp1right), rest671)
end
|  ( 69, ( ( _, ( MlyValue.app_exp app_exp1, _, app_exp1right)) :: ( _
, ( MlyValue.id id1, (idleft as id1left), idright)) :: rest671)) =>
 let val  result = MlyValue.app_exp (fn _ => let val  (id as id1) = 
id1 ()
 val  (app_exp as app_exp1) = app_exp1 ()
 in (
fn env =>
                             let val _ = mungeEnvForFwdRef env id
                                 val (v,f) = var'n'fix env id ((#1(argument))(idleft,idright))
                             in
                                 {item=(#3(argument)) idleft idright v,
                                  loc=(#2(argument)) idleft idright,
                                  fixity=SOME f}
                                 ::
                                 (app_exp env)
                             end
)
end)
 in ( LrTable.NT 37, ( result, id1left, app_exp1right), rest671)
end
|  ( 70, ( ( _, ( MlyValue.exp exp1, _, (expright as exp1right))) :: _
 :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), _)) :: rest671)) =>
 let val  result = MlyValue.recordexp_component (fn _ => let val  (ID
 as ID1) = ID1 ()
 val  (exp as exp1) = exp1 ()
 in (fn env => (#3(argument)) IDleft expright (RecordExp(ID, exp env))
)
end)
 in ( LrTable.NT 31, ( result, ID1left, exp1right), rest671)
end
|  ( 71, ( ( _, ( MlyValue.recordexp_component_list 
recordexp_component_list1, _, recordexp_component_list1right)) :: _ ::
 ( _, ( MlyValue.recordexp_component recordexp_component1, 
recordexp_component1left, _)) :: rest671)) => let val  result = 
MlyValue.recordexp_component_list (fn _ => let val  (
recordexp_component as recordexp_component1) = recordexp_component1 ()
 val  (recordexp_component_list as recordexp_component_list1) = 
recordexp_component_list1 ()
 in (
fn env =>
                                       (recordexp_component env) :: (recordexp_component_list env)
)
end)
 in ( LrTable.NT 32, ( result, recordexp_component1left, 
recordexp_component_list1right), rest671)
end
|  ( 72, ( ( _, ( MlyValue.recordexp_component recordexp_component1, 
recordexp_component1left, recordexp_component1right)) :: rest671)) =>
 let val  result = MlyValue.recordexp_component_list (fn _ => let val 
 (recordexp_component as recordexp_component1) = recordexp_component1
 ()
 in (fn env => [recordexp_component env])
end)
 in ( LrTable.NT 32, ( result, recordexp_component1left, 
recordexp_component1right), rest671)
end
|  ( 73, ( ( _, ( MlyValue.INT INT1, (INTleft as INT1left), (INTright
 as INT1right))) :: rest671)) => let val  result = MlyValue.aexp (fn _
 => let val  (INT as INT1) = INT1 ()
 in (
fn env => let val tc = ParseLib.Type.get "int" ((#1(argument))(INTleft, INTright)) env
                                           in
                                               (#3(argument)) INTleft INTright (Const(Tycon(tc, X.O(X.Literal (X.getIntSort(), INT)), []),
                                                                              INT))
                                           end
)
end)
 in ( LrTable.NT 38, ( result, INT1left, INT1right), rest671)
end
|  ( 74, ( ( _, ( MlyValue.REAL REAL1, (REALleft as REAL1left), (
REALright as REAL1right))) :: rest671)) => let val  result = 
MlyValue.aexp (fn _ => let val  (REAL as REAL1) = REAL1 ()
 in (
fn env =>
                                        let val tc = ParseLib.Type.get "real" ((#1(argument))(REALleft, REALright)) env
                                            val texp =
                                                     if Real.== (Option.valOf (Real.fromString REAL), 0.0) then
                                                         let val zz = IndexSym.fresh "zz"
                                                         in
                                                             Univ(zz, X.Base (X.getDimSort()), Tycon(tc, X.O (X.Uvar zz), []))
                                                         end
                                                     else
                                                         Tycon(tc, X.N, [])
                                        in
                                            (#3(argument)) REALleft REALright (Const(texp, REAL))
                                        end
)
end)
 in ( LrTable.NT 38, ( result, REAL1left, REAL1right), rest671)
end
|  ( 75, ( ( _, ( MlyValue.STRING STRING1, (STRINGleft as STRING1left)
, (STRINGright as STRING1right))) :: rest671)) => let val  result = 
MlyValue.aexp (fn _ => let val  (STRING as STRING1) = STRING1 ()
 in (
fn env => let val tc = ParseLib.Type.get "string" ((#1(argument))(STRINGleft, STRINGright)) env
                                           in
                                               (#3(argument)) STRINGleft STRINGright (Const(Tycon(tc, X.N, []),
                                                                              STRING))
                                           end
)
end)
 in ( LrTable.NT 38, ( result, STRING1left, STRING1right), rest671)

end
|  ( 76, ( ( _, ( MlyValue.CHAR CHAR1, (CHARleft as CHAR1left), (
CHARright as CHAR1right))) :: rest671)) => let val  result = 
MlyValue.aexp (fn _ => let val  (CHAR as CHAR1) = CHAR1 ()
 in (
fn env => let val tc = ParseLib.Type.get "char" ((#1(argument))(CHARleft, CHARright)) env
                                           in
                                               (#3(argument)) CHARleft CHARright (Const(Tycon(tc, X.N, []),
                                                                              CHAR))
                                           end
)
end)
 in ( LrTable.NT 38, ( result, CHAR1left, CHAR1right), rest671)
end
|  ( 77, ( ( _, ( _, _, (RBRACEright as RBRACE1right))) :: ( _, ( 
MlyValue.recordexp_component_list recordexp_component_list1, _, _)) ::
 ( _, ( _, (LBRACEleft as LBRACE1left), _)) :: rest671)) => let val  
result = MlyValue.aexp (fn _ => let val  (recordexp_component_list as 
recordexp_component_list1) = recordexp_component_list1 ()
 in (
fn env =>
                                               let val recordexps = recordexp_component_list env
                                               in
                                                   (#3(argument)) LBRACEleft RBRACEright (Merge recordexps)
                                               end
)
end)
 in ( LrTable.NT 38, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 78, ( ( _, ( _, _, (ENDright as END1right))) :: ( _, ( 
MlyValue.exp exp1, _, _)) :: _ :: ( _, ( MlyValue.decs decs1, _, _))
 :: ( _, ( _, (LETleft as LET1left), _)) :: rest671)) => let val  
result = MlyValue.aexp (fn _ => let val  (decs as decs1) = decs1 ()
 val  (exp as exp1) = exp1 ()
 in (
fn env => 
                                      let val _ = decslevel := !decslevel + 1
                                          val (env, dsl) = decs env
                                      in 
                                          (#3(argument)) LETleft ENDright (Let (dsl, exp env))
                                          before decslevel := !decslevel - 1
                                      end
)
end)
 in ( LrTable.NT 38, ( result, LET1left, END1right), rest671)
end
|  ( 79, ( ( _, ( _, ENDleft, END1right)) :: ( _, ( MlyValue.exp exp1,
 _, _)) :: ( _, ( _, _, INright)) :: ( _, ( 
MlyValue.annotationtypelist annotationtypelist1, _, _)) :: ( _, ( _, 
LETHINT1left, _)) :: rest671)) => let val  result = MlyValue.aexp (fn
 _ => let val  (annotationtypelist as annotationtypelist1) = 
annotationtypelist1 ()
 val  (exp as exp1) = exp1 ()
 in (
fn env =>
                                         let val (_, anno) = annotationtypelist env
                                         in
                                             (#3(argument)) INright ENDleft (Lethint(anno, exp env))
                                         end
)
end)
 in ( LrTable.NT 38, ( result, LETHINT1left, END1right), rest671)
end
|  ( 80, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.exp exp1, _, _)) :: _ :: ( _, ( MlyValue.INT INT1, _, _)) :: 
( _, ( _, (HASHleft as HASH1left), _)) :: rest671)) => let val  result
 = MlyValue.aexp (fn _ => let val  (INT as INT1) = INT1 ()
 val  (exp as exp1) = exp1 ()
 in (
fn env => (#3(argument)) HASHleft RPARENright (Proj (INT, exp env)))

end)
 in ( LrTable.NT 38, ( result, HASH1left, RPAREN1right), rest671)
end
|  ( 81, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.exp exp1, _, _)) :: _ :: ( _, ( MlyValue.ID ID1, _, _)) :: (
 _, ( _, (HASHleft as HASH1left), _)) :: rest671)) => let val  result
 = MlyValue.aexp (fn _ => let val  (ID as ID1) = ID1 ()
 val  (exp as exp1) = exp1 ()
 in (
fn env => (#3(argument)) HASHleft RPARENright (Proj (ID, exp env)))

end)
 in ( LrTable.NT 38, ( result, HASH1left, RPAREN1right), rest671)
end
|  ( 82, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( _, (
LPARENleft as LPAREN1left), _)) :: rest671)) => let val  result = 
MlyValue.aexp (fn _ => (
fn env => (#3(argument)) LPARENleft RPARENright (Tuple [])))
 in ( LrTable.NT 38, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 83, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.exp exp1, _,
 _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.aexp (fn _ => let val  (exp as exp1) = exp1 ()
 in (fn env => exp env)
end)
 in ( LrTable.NT 38, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 84, ( ( _, ( _, _, (RPARENright as RPAREN1right))) :: ( _, ( 
MlyValue.exp_2c exp_2c1, _, _)) :: ( _, ( _, (LPARENleft as 
LPAREN1left), _)) :: rest671)) => let val  result = MlyValue.aexp (fn
 _ => let val  (exp_2c as exp_2c1) = exp_2c1 ()
 in (
fn env => case exp_2c of
                                     [exp] => raise Option
                                   | list => (#3(argument)) LPARENleft RPARENright (Tuple (Basic.mapapply list env))
)
end)
 in ( LrTable.NT 38, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 85, ( ( _, ( _, _, (RBRACKright as RBRACK1right))) :: ( _, ( 
MlyValue.exp_list exp_list1, exp_listleft, exp_listright)) :: ( _, ( _
, (LBRACKleft as LBRACK1left), _)) :: rest671)) => let val  result = 
MlyValue.aexp (fn _ => let val  (exp_list as exp_list1) = exp_list1 ()
 in (
fn env =>
                                 let val {nil= nil_pv, cons=cons_pv} = ParseLib.Con.get_list ((#1(argument))(exp_listleft,exp_listright)) env
                                     fun aux [] = (#3(argument))  LBRACKleft RBRACKright (Con nil_pv)
                                       | aux (exp::exps) = (#3(argument)) LBRACKleft RBRACKright
                                             (Conapp (cons_pv,
                                                   (#3(argument)) LBRACKleft RBRACKright (Tuple([exp env, aux exps]))))
                                 in
                                     aux exp_list
                                 end
)
end)
 in ( LrTable.NT 38, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 86, ( ( _, ( MlyValue.exp_2c exp_2c1, exp_2c1left, exp_2c1right))
 :: rest671)) => let val  result = MlyValue.exp_list (fn _ => let val 
 (exp_2c as exp_2c1) = exp_2c1 ()
 in (exp_2c)
end)
 in ( LrTable.NT 36, ( result, exp_2c1left, exp_2c1right), rest671)

end
|  ( 87, ( ( _, ( MlyValue.exp exp1, exp1left, exp1right)) :: rest671)
) => let val  result = MlyValue.exp_list (fn _ => let val  (exp as 
exp1) = exp1 ()
 in ([exp])
end)
 in ( LrTable.NT 36, ( result, exp1left, exp1right), rest671)
end
|  ( 88, ( rest671)) => let val  result = MlyValue.exp_list (fn _ => (
[]))
 in ( LrTable.NT 36, ( result, defaultPos, defaultPos), rest671)
end
|  ( 89, ( ( _, ( MlyValue.arm arm1, arm1left, arm1right)) :: rest671)
) => let val  result = MlyValue.arms (fn _ => let val  (arm as arm1) =
 arm1 ()
 in ([arm])
end)
 in ( LrTable.NT 39, ( result, arm1left, arm1right), rest671)
end
|  ( 90, ( ( _, ( MlyValue.arms arms1, _, arms1right)) :: _ :: ( _, ( 
MlyValue.arm arm1, arm1left, _)) :: rest671)) => let val  result = 
MlyValue.arms (fn _ => let val  (arm as arm1) = arm1 ()
 val  (arms as arms1) = arms1 ()
 in (arm :: arms)
end)
 in ( LrTable.NT 39, ( result, arm1left, arms1right), rest671)
end
|  ( 91, ( ( _, ( MlyValue.id id1, id1left, id1right)) :: rest671)) =>
 let val  result = MlyValue.atpattern (fn _ => let val  (id as id1) = 
id1 ()
 in (
fn env =>
                        let in case ParseLib.Pvar.lookup_soft env id of
                            SOME (ParseLib.Convar, pv) => (env, CtorPattern(pv, NONE))
                          | _ => 
                                let val pv = PV.fresh id
                                in
                                    (ParseLib.Pvar.extend_DefinedVal env [(id, pv)], VarPattern pv)
                                end
                        end
)
end)
 in ( LrTable.NT 44, ( result, id1left, id1right), rest671)
end
|  ( 92, ( ( _, ( _, _, RBRACK1right)) :: ( _, ( MlyValue.patternlz 
patternlz1, patternlzleft, patternlzright)) :: ( _, ( _, LBRACK1left,
 _)) :: rest671)) => let val  result = MlyValue.atpattern (fn _ => let
 val  (patternlz as patternlz1) = patternlz1 ()
 in (
fn env =>
                                    let val {nil= nil_pv, cons= cons_pv} = ParseLib.Con.get_list ((#1(argument))(patternlzleft, patternlzright)) env
                                        val (env, pat_list) = patternlz env
                                        fun loop env [] = (env, CtorPattern (nil_pv, NONE))
                                          | loop env (head :: pats) =
                                                let val (env, tail) = loop env pats
                                                in
                                                    (env, CtorPattern (cons_pv, SOME (TuplePattern[head, tail])))
                                                end
                                    in
                                        loop env pat_list
                                    end
)
end)
 in ( LrTable.NT 44, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 93, ( ( _, ( _, WILD1left, WILD1right)) :: rest671)) => let val  
result = MlyValue.atpattern (fn _ => (fn env => (env, WildPattern)))
 in ( LrTable.NT 44, ( result, WILD1left, WILD1right), rest671)
end
|  ( 94, ( ( _, ( MlyValue.INT INT1, INT1left, INT1right)) :: rest671)
) => let val  result = MlyValue.atpattern (fn _ => let val  (INT as 
INT1) = INT1 ()
 in (fn env => (env, IntPattern (valOf (Int.fromString INT))))
end)
 in ( LrTable.NT 44, ( result, INT1left, INT1right), rest671)
end
|  ( 95, ( ( _, ( MlyValue.STRING STRING1, STRING1left, STRING1right))
 :: rest671)) => let val  result = MlyValue.atpattern (fn _ => let
 val  (STRING as STRING1) = STRING1 ()
 in (fn env => (env, StringPattern STRING))
end)
 in ( LrTable.NT 44, ( result, STRING1left, STRING1right), rest671)

end
|  ( 96, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.atpattern (fn _ => (
fn env => (env, TuplePattern [])))
 in ( LrTable.NT 44, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 97, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.patternl 
patternl1, _, _)) :: ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, 
( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.atpattern (fn _ => let val  (pattern as pattern1) = pattern1
 ()
 val  (patternl as patternl1) = patternl1 ()
 in (
fn env =>
                                          let val (env, pattern') = pattern env
                                              val (env, patternl'') = patternl env
                                          in
                                              case patternl'' of
                                                  [] => (env, pattern')
                                                | patternl'' => 
                                                      (env, TuplePattern (pattern' :: patternl''))
                                          end
)
end)
 in ( LrTable.NT 44, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 98, ( ( _, ( MlyValue.atpattern atpattern1, _, atpattern1right))
 :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), IDright)) :: rest671)
) => let val  result = MlyValue.atpattern (fn _ => let val  (ID as ID1
) = ID1 ()
 val  (atpattern as atpattern1) = atpattern1 ()
 in (
fn env => case ParseLib.Pvar.lookup_soft env ID of
                          SOME (ParseLib.Convar, pv) =>
                              let val (env, atpattern') = atpattern env
                              in
                                  (env,
                                   CtorPattern(pv, SOME atpattern'))
                              end
                        | _ => ((#1(argument))(IDleft,IDright) ("identifier \"" ^ ID ^ "\" in constructor position in pattern is not a constructor") ;
                                raise Debug.StdExcept("", ""))
)
end)
 in ( LrTable.NT 44, ( result, ID1left, atpattern1right), rest671)
end
|  ( 99, ( ( _, ( MlyValue.atpattern atpattern1, _, atpattern1right))
 :: _ :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: rest671)) => let val 
 result = MlyValue.atpattern (fn _ => let val  (ID as ID1) = ID1 ()
 val  (atpattern as atpattern1) = atpattern1 ()
 in (
fn env =>
                             let val pv = PV.fresh ID
                                 val env = ParseLib.Pvar.extend_DefinedVal env [(ID, pv)]
                                 val (env, atpattern') = atpattern env
                             in
                                 (env, AsPattern (pv, atpattern'))
                             end
)
end)
 in ( LrTable.NT 44, ( result, ID1left, atpattern1right), rest671)
end
|  ( 100, ( ( _, ( MlyValue.atpattern atpattern1, atpattern1left, 
atpattern1right)) :: rest671)) => let val  result = MlyValue.pattern
 (fn _ => let val  (atpattern as atpattern1) = atpattern1 ()
 in (fn env => atpattern env)
end)
 in ( LrTable.NT 41, ( result, atpattern1left, atpattern1right), 
rest671)
end
|  ( 101, ( ( _, ( MlyValue.pattern pattern1, _, (patternright as 
pattern1right))) :: _ :: ( _, ( MlyValue.atpattern atpattern1, (
atpatternleft as atpattern1left), _)) :: rest671)) => let val  result
 = MlyValue.pattern (fn _ => let val  (atpattern as atpattern1) = 
atpattern1 ()
 val  (pattern as pattern1) = pattern1 ()
 in (
fn env =>
                                     let val (env, head) = atpattern env
                                         val (env, tail) = pattern env
                                         val {cons= cons_pv, ...} = ParseLib.Con.get_list ((#1(argument))(atpatternleft, patternright)) env
                                     in
                                         (env, CtorPattern (cons_pv, SOME (TuplePattern[head, tail])))
                                     end
)
end)
 in ( LrTable.NT 41, ( result, atpattern1left, pattern1right), rest671
)
end
|  ( 102, ( rest671)) => let val  result = MlyValue.patternl (fn _ =>
 (fn env => (env, [])))
 in ( LrTable.NT 42, ( result, defaultPos, defaultPos), rest671)
end
|  ( 103, ( ( _, ( MlyValue.patternl patternl1, _, patternl1right)) ::
 ( _, ( MlyValue.pattern pattern1, _, _)) :: ( _, ( _, COMMA1left, _))
 :: rest671)) => let val  result = MlyValue.patternl (fn _ => let val 
 (pattern as pattern1) = pattern1 ()
 val  (patternl as patternl1) = patternl1 ()
 in (
fn env =>
                              let val (env, pattern') = pattern env
                                  val (env, patternl'') = patternl env
                              in
                                  (env, pattern' :: patternl'')
                              end
)
end)
 in ( LrTable.NT 42, ( result, COMMA1left, patternl1right), rest671)

end
|  ( 104, ( rest671)) => let val  result = MlyValue.patternlz (fn _ =>
 (fn env => (env, [])))
 in ( LrTable.NT 43, ( result, defaultPos, defaultPos), rest671)
end
|  ( 105, ( ( _, ( MlyValue.patternl patternl1, _, patternl1right)) ::
 ( _, ( MlyValue.pattern pattern1, pattern1left, _)) :: rest671)) =>
 let val  result = MlyValue.patternlz (fn _ => let val  (pattern as 
pattern1) = pattern1 ()
 val  (patternl as patternl1) = patternl1 ()
 in (
fn env =>
                              let val (env, pattern') = pattern env
                                  val (env, patternl'') = patternl env
                              in
                                  (env, pattern' :: patternl'')
                              end
)
end)
 in ( LrTable.NT 43, ( result, pattern1left, patternl1right), rest671)

end
|  ( 106, ( ( _, ( MlyValue.expD expD1, _, expD1right)) :: _ :: ( _, (
 MlyValue.pattern pattern1, pattern1left, _)) :: rest671)) => let val 
 result = MlyValue.arm (fn _ => let val  (pattern as pattern1) = 
pattern1 ()
 val  (expD as expD1) = expD1 ()
 in (
fn env => 
                                        let val (env', pattern') = pattern env
                                        in
                                            Arm(pattern', expD env')
                                        end
)
end)
 in ( LrTable.NT 40, ( result, pattern1left, expD1right), rest671)
end
|  ( 107, ( ( _, ( MlyValue.idw idw1, idw1left, idw1right)) :: rest671
)) => let val  result = MlyValue.idl (fn _ => let val  (idw as idw1) =
 idw1 ()
 in ([idw])
end)
 in ( LrTable.NT 47, ( result, idw1left, idw1right), rest671)
end
|  ( 108, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.ids ids1, _
, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.idl (fn _ => let val  (ids as ids1) = ids1 ()
 in (ids)
end)
 in ( LrTable.NT 47, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 109, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.idl (fn _ => ([]))
 in ( LrTable.NT 47, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 110, ( ( _, ( MlyValue.idw idw1, idw1left, idw1right)) :: rest671
)) => let val  result = MlyValue.ids (fn _ => let val  (idw as idw1) =
 idw1 ()
 in ([idw])
end)
 in ( LrTable.NT 48, ( result, idw1left, idw1right), rest671)
end
|  ( 111, ( ( _, ( MlyValue.ids ids1, _, ids1right)) :: _ :: ( _, ( 
MlyValue.idw idw1, idw1left, _)) :: rest671)) => let val  result = 
MlyValue.ids (fn _ => let val  (idw as idw1) = idw1 ()
 val  (ids as ids1) = ids1 ()
 in (idw::ids)
end)
 in ( LrTable.NT 48, ( result, idw1left, ids1right), rest671)
end
|  ( 112, ( ( _, ( MlyValue.exp_2c exp_2c1, _, exp_2c1right)) :: _ :: 
( _, ( MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val  
result = MlyValue.exp_2c (fn _ => let val  (exp as exp1) = exp1 ()
 val  (exp_2c as exp_2c1) = exp_2c1 ()
 in (exp::exp_2c)
end)
 in ( LrTable.NT 35, ( result, exp1left, exp_2c1right), rest671)
end
|  ( 113, ( ( _, ( MlyValue.exp exp2, _, exp2right)) :: _ :: ( _, ( 
MlyValue.exp exp1, exp1left, _)) :: rest671)) => let val  result = 
MlyValue.exp_2c (fn _ => let val  exp1 = exp1 ()
 val  exp2 = exp2 ()
 in ([exp1,exp2])
end)
 in ( LrTable.NT 35, ( result, exp1left, exp2right), rest671)
end
|  ( 114, ( ( _, ( MlyValue.X_exp X_exp1, (X_expleft as X_exp1left), (
X_expright as X_exp1right))) :: rest671)) => let val  result = 
MlyValue.proposition (fn _ => let val  (X_exp as X_exp1) = X_exp1 ()
 in (
fn env =>
                      case X_exp env of
                          X.App(sym, exp) => let in case X.getSyminfo sym of
                              NONE => ((#1(argument))(X_expleft, X_expright) ("undefined index function/predicate: " ^ IndexSym.toShortString sym); X.TRUE)
                            | SOME (X.IFun [{domain= domain, range= codomain, ...}]) =>
                              let in if codomain = X.Base (X.getBoolSort()) then
                                        let in
                                            if IndexSym.toShortString sym = "=" then
                                                let in case (domain, exp) of
                                                    (X.Product[sort1, sort2], X.Tuple[exp1, exp2]) => X.EQ(sort1, exp1, exp2)
                                                end
                                            else
                                                X.PRED(sym, exp)
                                        end
                                     else
                                         ((#1(argument))(X_expleft, X_expright) ("`" ^ IndexSym.toShortString sym ^ "' is a function, not a predicate");
                                          X.TRUE)
                              end
                            | SOME (X.IFun _) => ((#1(argument))(X_expleft, X_expright) ("`" ^ IndexSym.toShortString sym
                                                                                  ^ "' is multi-sorted, and is therefore a function, not a predicate");
                                          X.TRUE)
                                           end
                        | _ => ((#1(argument))(X_expleft, X_expright) ("proposition expected"); X.TRUE)
                              
)
end)
 in ( LrTable.NT 49, ( result, X_exp1left, X_exp1right), rest671)
end
|  ( 115, ( ( _, ( MlyValue.proposition proposition2, _, 
proposition2right)) :: _ :: ( _, ( MlyValue.proposition proposition1, 
proposition1left, _)) :: rest671)) => let val  result = 
MlyValue.proposition (fn _ => let val  proposition1 = proposition1 ()
 val  proposition2 = proposition2 ()
 in (fn env => X.AND(proposition1 env, proposition2 env))
end)
 in ( LrTable.NT 49, ( result, proposition1left, proposition2right), 
rest671)
end
|  ( 116, ( ( _, ( MlyValue.proposition proposition2, _, 
proposition2right)) :: _ :: ( _, ( MlyValue.proposition proposition1, 
proposition1left, _)) :: rest671)) => let val  result = 
MlyValue.proposition (fn _ => let val  proposition1 = proposition1 ()
 val  proposition2 = proposition2 ()
 in (fn env => X.OR(proposition1 env, proposition2 env))
end)
 in ( LrTable.NT 49, ( result, proposition1left, proposition2right), 
rest671)
end
|  ( 117, ( ( _, ( MlyValue.TYVAR TYVAR1, TYVAR1left, TYVAR1right)) ::
 rest671)) => let val  result = MlyValue.tyvarseq (fn _ => let val  (
TYVAR as TYVAR1) = TYVAR1 ()
 in ([TYVAR])
end)
 in ( LrTable.NT 50, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 118, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.tyvars 
tyvars1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val 
 result = MlyValue.tyvarseq (fn _ => let val  (tyvars as tyvars1) = 
tyvars1 ()
 in (tyvars)
end)
 in ( LrTable.NT 50, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 119, ( rest671)) => let val  result = MlyValue.tyvarseq (fn _ =>
 ([]))
 in ( LrTable.NT 50, ( result, defaultPos, defaultPos), rest671)
end
|  ( 120, ( ( _, ( MlyValue.variancesymbol variancesymbol1, _, 
variancesymbol1right)) :: ( _, ( MlyValue.TYVAR TYVAR1, TYVAR1left, _)
) :: rest671)) => let val  result = MlyValue.tyvarvariance (fn _ =>
 let val  (TYVAR as TYVAR1) = TYVAR1 ()
 val  (variancesymbol as variancesymbol1) = variancesymbol1 ()
 in ((TYVAR, variancesymbol))
end)
 in ( LrTable.NT 51, ( result, TYVAR1left, variancesymbol1right), 
rest671)
end
|  ( 121, ( ( _, ( MlyValue.tyvarvarianceseq tyvarvarianceseq1, _, 
tyvarvarianceseq1right)) :: ( _, ( MlyValue.tyvarvariance 
tyvarvariance1, tyvarvariance1left, _)) :: rest671)) => let val  
result = MlyValue.tyvarvarianceseq (fn _ => let val  (tyvarvariance
 as tyvarvariance1) = tyvarvariance1 ()
 val  (tyvarvarianceseq as tyvarvarianceseq1) = tyvarvarianceseq1 ()
 in (tyvarvariance :: tyvarvarianceseq)
end)
 in ( LrTable.NT 52, ( result, tyvarvariance1left, 
tyvarvarianceseq1right), rest671)
end
|  ( 122, ( rest671)) => let val  result = MlyValue.tyvarvarianceseq
 (fn _ => ([]))
 in ( LrTable.NT 52, ( result, defaultPos, defaultPos), rest671)
end
|  ( 123, ( ( _, ( MlyValue.TYVAR TYVAR1, TYVAR1left, TYVAR1right)) ::
 rest671)) => let val  result = MlyValue.tyvars (fn _ => let val  (
TYVAR as TYVAR1) = TYVAR1 ()
 in ([TYVAR])
end)
 in ( LrTable.NT 53, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 124, ( ( _, ( MlyValue.tyvars tyvars1, _, tyvars1right)) :: _ :: 
( _, ( MlyValue.TYVAR TYVAR1, TYVAR1left, _)) :: rest671)) => let val 
 result = MlyValue.tyvars (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1
 ()
 val  (tyvars as tyvars1) = tyvars1 ()
 in (TYVAR::tyvars)
end)
 in ( LrTable.NT 53, ( result, TYVAR1left, tyvars1right), rest671)
end
|  ( 125, ( ( _, ( MlyValue.texpI texpI1, texpI1left, texpI1right)) ::
 rest671)) => let val  result = MlyValue.texp (fn _ => let val  (texpI
 as texpI1) = texpI1 ()
 in (texpI)
end)
 in ( LrTable.NT 54, ( result, texpI1left, texpI1right), rest671)
end
|  ( 126, ( ( _, ( MlyValue.dashalltail dashalltail1, _, 
dashalltail1right)) :: ( _, ( _, DASHALL1left, _)) :: rest671)) => let
 val  result = MlyValue.texp (fn _ => let val  (dashalltail as 
dashalltail1) = dashalltail1 ()
 in (dashalltail)
end)
 in ( LrTable.NT 54, ( result, DASHALL1left, dashalltail1right), 
rest671)
end
|  ( 127, ( ( _, ( MlyValue.texpC texpC1, texpC1left, texpC1right)) ::
 rest671)) => let val  result = MlyValue.texpI (fn _ => let val  (
texpC as texpC1) = texpC1 ()
 in (texpC)
end)
 in ( LrTable.NT 55, ( result, texpC1left, texpC1right), rest671)
end
|  ( 128, ( ( _, ( MlyValue.texpC texpC1, _, texpC1right)) :: _ :: ( _
, ( MlyValue.texpI texpI1, texpI1left, _)) :: rest671)) => let val  
result = MlyValue.texpI (fn _ => let val  (texpI as texpI1) = texpI1
 ()
 val  (texpC as texpC1) = texpC1 ()
 in (
fn env => 
                                        let val (env', tLeft) = texpI env
                                            val (env'', tRight) = texpC env'
                                        in (env'', Sect(tLeft, tRight))
                                        end
)
end)
 in ( LrTable.NT 55, ( result, texpI1left, texpC1right), rest671)
end
|  ( 129, ( ( _, ( MlyValue.texpC texpC1, _, texpC1right)) :: _ :: ( _
, ( MlyValue.texpI texpI1, texpI1left, _)) :: rest671)) => let val  
result = MlyValue.texpI (fn _ => let val  (texpI as texpI1) = texpI1
 ()
 val  (texpC as texpC1) = texpC1 ()
 in (
fn env => 
                                        let val (env', tLeft) = texpI env
                                            val (env'', tRight) = texpC env'
                                        in (env'', Rsect(tLeft, tRight))
                                        end
)
end)
 in ( LrTable.NT 55, ( result, texpI1left, texpC1right), rest671)
end
|  ( 130, ( ( _, ( MlyValue.texpD texpD1, texpD1left, texpD1right)) ::
 rest671)) => let val  result = MlyValue.texpC (fn _ => let val  (
texpD as texpD1) = texpD1 ()
 in (texpD)
end)
 in ( LrTable.NT 56, ( result, texpD1left, texpD1right), rest671)
end
|  ( 131, ( ( _, ( MlyValue.texpC texpC1, _, texpC1right)) :: _ :: ( _
, ( MlyValue.texpD texpD1, texpD1left, _)) :: rest671)) => let val  
result = MlyValue.texpC (fn _ => let val  (texpD as texpD1) = texpD1
 ()
 val  (texpC as texpC1) = texpC1 ()
 in (
fn env => 
                                        let val (env', tLeft) = texpD env
                                            val (env'', tRight) = texpC env'
                                        in (env'', Arrow(tLeft, tRight))
                                        end
)
end)
 in ( LrTable.NT 56, ( result, texpD1left, texpC1right), rest671)
end
|  ( 132, ( ( _, ( MlyValue.texp texp1, _, texp1right)) :: _ :: ( _, (
 MlyValue.sort sort1, _, _)) :: _ :: ( _, ( MlyValue.commaids 
commaids1, _, _)) :: ( _, ( MlyValue.ID ID1, ID1left, _)) :: rest671))
 => let val  result = MlyValue.dashalltail (fn _ => let val  (ID as 
ID1) = ID1 ()
 val  (commaids as commaids1) = commaids1 ()
 val  (sort as sort1) = sort1 ()
 val  (texp as texp1) = texp1 ()
 in (
fn env => 
                          let
                              val _ = dprnt "dashalltail ID"
                              val srt = sort env
                              val idlist = ID :: commaids
                              val bindings = map (fn idstring => (idstring, (IndexSym.fresh idstring, X.IUVar srt))) idlist
                              val env' = ParseLib.extend_iv env bindings
                              val (env'', t) = texp env'
                              val  _ = dprint (fn () => "texp in scope of Univ: " ^ Print.pTexp t)
                              fun buildUnivs [] = t
                                | buildUnivs ((_, (iv, _)) :: rest) = Univ(iv, srt, buildUnivs rest)
                          in
                              (env, buildUnivs bindings)
                          end
)
end)
 in ( LrTable.NT 63, ( result, ID1left, texp1right), rest671)
end
|  ( 133, ( ( _, ( MlyValue.texp texp1, _, texp1right)) :: _ :: ( _, (
 MlyValue.commatyvars commatyvars1, _, _)) :: ( _, ( MlyValue.TYVAR 
TYVAR1, TYVAR1left, _)) :: rest671)) => let val  result = 
MlyValue.dashalltail (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 val  (commatyvars as commatyvars1) = commatyvars1 ()
 val  (texp as texp1) = texp1 ()
 in (
fn env =>
                          let
                              val idlist = TYVAR :: commatyvars
                              val bindings = map (fn idstring => (idstring, TV.fresh idstring)) idlist
                              val env' = ParseLib.Tyvar.extend env bindings
                              val (env'', t) = texp env'
                              fun buildAlls [] = t
                                | buildAlls ((_, tv) :: rest) = All(tv, Types.outer_universe, buildAlls rest)
                          in
                              (env, buildAlls bindings)
                          end
)
end)
 in ( LrTable.NT 63, ( result, TYVAR1left, texp1right), rest671)
end
|  ( 134, ( ( _, ( MlyValue.commaids commaids1, _, commaids1right)) ::
 ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, COMMA1left, _)) :: 
rest671)) => let val  result = MlyValue.commaids (fn _ => let val  (ID
 as ID1) = ID1 ()
 val  (commaids as commaids1) = commaids1 ()
 in (ID :: commaids)
end)
 in ( LrTable.NT 65, ( result, COMMA1left, commaids1right), rest671)

end
|  ( 135, ( rest671)) => let val  result = MlyValue.commaids (fn _ =>
 ([]))
 in ( LrTable.NT 65, ( result, defaultPos, defaultPos), rest671)
end
|  ( 136, ( ( _, ( MlyValue.commatyvars commatyvars1, _, 
commatyvars1right)) :: ( _, ( MlyValue.TYVAR TYVAR1, _, _)) :: ( _, (
 _, COMMA1left, _)) :: rest671)) => let val  result = 
MlyValue.commatyvars (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 val  (commatyvars as commatyvars1) = commatyvars1 ()
 in (TYVAR :: commatyvars)
end)
 in ( LrTable.NT 66, ( result, COMMA1left, commatyvars1right), rest671
)
end
|  ( 137, ( rest671)) => let val  result = MlyValue.commatyvars (fn _
 => ([]))
 in ( LrTable.NT 66, ( result, defaultPos, defaultPos), rest671)
end
|  ( 138, ( ( _, ( _, _, RBRACK1right)) :: ( _, ( MlyValue.X_explist 
X_explist1, _, _)) :: ( _, ( _, LBRACK1left, _)) :: rest671)) => let
 val  result = MlyValue.indexrefinement (fn _ => let val  (X_explist
 as X_explist1) = X_explist1 ()
 in (fn env => X.O (X_explist env))
end)
 in ( LrTable.NT 67, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 139, ( rest671)) => let val  result = MlyValue.indexrefinement
 (fn _ => (fn env => X.N))
 in ( LrTable.NT 67, ( result, defaultPos, defaultPos), rest671)
end
|  ( 140, ( ( _, ( MlyValue.texpE texpE1, texpE1left, texpE1right)) ::
 rest671)) => let val  result = MlyValue.texpD (fn _ => let val  (
texpE as texpE1) = texpE1 ()
 in (
fn env => 
                                        let val (env', tl) = texpE env
                                        in (env', case tl of [t] => t | tl => Product tl)
                                        end
)
end)
 in ( LrTable.NT 57, ( result, texpE1left, texpE1right), rest671)
end
|  ( 141, ( ( _, ( MlyValue.texpD texpD1, _, texpD1right)) :: _ :: ( _
, ( MlyValue.sort sort1, _, _)) :: _ :: ( _, ( MlyValue.commaids 
commaids1, _, _)) :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, 
DASHEXISTS1left, _)) :: rest671)) => let val  result = MlyValue.texpD
 (fn _ => let val  (ID as ID1) = ID1 ()
 val  (commaids as commaids1) = commaids1 ()
 val  (sort as sort1) = sort1 ()
 val  (texpD as texpD1) = texpD1 ()
 in (
fn env => 
                                                            let val srt = sort env
                                                                val idlist = ID :: commaids
                                                                val bindings = map (fn idstring => (idstring, (IndexSym.fresh idstring, X.IEVar srt))) idlist
                                                                val env' = ParseLib.extend_iv env bindings
                                                                val (env'', t) = texpD env'
                                                                fun buildExiss [] = t
                                                                  | buildExiss ((_, (iv, _)) :: rest) = Exis(iv, srt, buildExiss rest)
                                                            in
                                                                (env, buildExiss bindings)
                                                            end
)
end)
 in ( LrTable.NT 57, ( result, DASHEXISTS1left, texpD1right), rest671)

end
|  ( 142, ( ( _, ( MlyValue.texpD texpD1, _, texpD1right)) :: _ :: ( _
, ( MlyValue.proposition proposition1, _, _)) :: ( _, ( _, LBRACK1left
, _)) :: rest671)) => let val  result = MlyValue.texpD (fn _ => let
 val  (proposition as proposition1) = proposition1 ()
 val  (texpD as texpD1) = texpD1 ()
 in (
fn env =>
                                                 let val prop = proposition env
                                                     val (env, t) = texpD env
                                                 in
                                                     (env, Conj(prop, t))
                                                 end
)
end)
 in ( LrTable.NT 57, ( result, LBRACK1left, texpD1right), rest671)
end
|  ( 143, ( ( _, ( MlyValue.texpU texpU1, texpU1left, texpU1right)) ::
 rest671)) => let val  result = MlyValue.texpE (fn _ => let val  (
texpU as texpU1) = texpU1 ()
 in (
fn env => 
                                        let val (env',t) = texpU env 
                                        in (env',[t])
                                        end
)
end)
 in ( LrTable.NT 58, ( result, texpU1left, texpU1right), rest671)
end
|  ( 144, ( ( _, ( MlyValue.texpU texpU1, _, texpU1right)) :: _ :: ( _
, ( MlyValue.texpE texpE1, texpE1left, _)) :: rest671)) => let val  
result = MlyValue.texpE (fn _ => let val  (texpE as texpE1) = texpE1
 ()
 val  (texpU as texpU1) = texpU1 ()
 in (
fn env => 
                                        let val (env',tl) = texpE env
                                            val (env'',t) = texpU env'
                                        in (env'', tl @ [t])
                                        end
)
end)
 in ( LrTable.NT 58, ( result, texpE1left, texpU1right), rest671)
end
|  ( 145, ( ( _, ( MlyValue.texpY texpY1, texpY1left, texpY1right)) ::
 rest671)) => let val  result = MlyValue.texpU (fn _ => let val  (
texpY as texpY1) = texpY1 ()
 in (texpY)
end)
 in ( LrTable.NT 59, ( result, texpY1left, texpY1right), rest671)
end
|  ( 146, ( ( _, ( MlyValue.texpU texpU2, _, texpU2right)) :: _ :: ( _
, ( MlyValue.texpU texpU1, texpU1left, _)) :: rest671)) => let val  
result = MlyValue.texpU (fn _ => let val  texpU1 = texpU1 ()
 val  texpU2 = texpU2 ()
 in (
fn env => 
                                       let val (env',tLeft) = texpU1 env
                                           val (env'',tRight) = texpU2 env'
                                       in (env'', Union(tLeft, tRight))
                                       end
)
end)
 in ( LrTable.NT 59, ( result, texpU1left, texpU2right), rest671)
end
|  ( 147, ( ( _, ( MlyValue.texpU texpU2, _, texpU2right)) :: _ :: ( _
, ( MlyValue.texpU texpU1, texpU1left, _)) :: rest671)) => let val  
result = MlyValue.texpU (fn _ => let val  texpU1 = texpU1 ()
 val  texpU2 = texpU2 ()
 in (
fn env => 
                                       let val (env',tLeft) = texpU1 env
                                           val (env'',tRight) = texpU2 env'
                                       in (env'', Runion(tLeft, tRight))
                                       end
)
end)
 in ( LrTable.NT 59, ( result, texpU1left, texpU2right), rest671)
end
|  ( 148, ( ( _, ( MlyValue.texp texp1, _, texp1right)) :: _ :: ( _, (
 MlyValue.ID ID1, ID1left, _)) :: rest671)) => let val  result = 
MlyValue.record_component (fn _ => let val  (ID as ID1) = ID1 ()
 val  (texp as texp1) = texp1 ()
 in (
fn env => let val (env, field_type) = texp env
                                                           in
                                                               (env, Record(ID, field_type))
                                                           end
)
end)
 in ( LrTable.NT 33, ( result, ID1left, texp1right), rest671)
end
|  ( 149, ( ( _, ( MlyValue.record_component_list 
record_component_list1, _, record_component_list1right)) :: _ :: ( _, 
( MlyValue.record_component record_component1, record_component1left,
 _)) :: rest671)) => let val  result = MlyValue.record_component_list
 (fn _ => let val  (record_component as record_component1) = 
record_component1 ()
 val  (record_component_list as record_component_list1) = 
record_component_list1 ()
 in (
fn env =>
                                                           let val (env, component) = record_component env
                                                               val (env, component_list) = record_component_list env
                                                           in
                                                               (env, component :: component_list)
                                                           end
)
end)
 in ( LrTable.NT 34, ( result, record_component1left, 
record_component_list1right), rest671)
end
|  ( 150, ( ( _, ( MlyValue.record_component record_component1, 
record_component1left, record_component1right)) :: rest671)) => let
 val  result = MlyValue.record_component_list (fn _ => let val  (
record_component as record_component1) = record_component1 ()
 in (
fn env =>
                                                           let val (env, component) = record_component env
                                                           in
                                                               (env, [component])
                                                           end
)
end)
 in ( LrTable.NT 34, ( result, record_component1left, 
record_component1right), rest671)
end
|  ( 151, ( ( _, ( MlyValue.texpZ texpZ1, texpZ1left, texpZ1right)) ::
 rest671)) => let val  result = MlyValue.texpY (fn _ => let val  (
texpZ as texpZ1) = texpZ1 ()
 in (texpZ)
end)
 in ( LrTable.NT 60, ( result, texpZ1left, texpZ1right), rest671)
end
|  ( 152, ( ( _, ( MlyValue.texp texp1, _, texp1right)) :: _ :: _ :: (
 _, ( MlyValue.proposition proposition1, _, _)) :: _ :: ( _, ( _, 
LBRACE1left, _)) :: rest671)) => let val  result = MlyValue.texpY (fn
 _ => let val  (proposition as proposition1) = proposition1 ()
 val  (texp as texp1) = texp1 ()
 in (
fn (env) =>
                                                 let val prop = proposition env
                                                     val (env, t) = texp (env)
                                                 in
                                                     (env, Implies(prop, t))
                                                 end
)
end)
 in ( LrTable.NT 60, ( result, LBRACE1left, texp1right), rest671)
end
|  ( 153, ( ( _, ( _, _, RBRACE1right)) :: ( _, ( 
MlyValue.record_component_list record_component_list1, _, _)) :: ( _, 
( _, LBRACE1left, _)) :: rest671)) => let val  result = MlyValue.texpY
 (fn _ => let val  (record_component_list as record_component_list1) =
 record_component_list1 ()
 in (
fn env =>
                                                 let val (env, fields : texp list) = record_component_list env
                                                     val intersection = List.foldl (Sdml.mkSect) Top fields
                                                 in
                                                     (env, intersection)
                                                 end
)
end)
 in ( LrTable.NT 60, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 154, ( ( _, ( MlyValue.texpl texpl1, _, texpl1right)) :: ( _, ( 
MlyValue.atomictexp atomictexp1, atomictexp1left, _)) :: rest671)) =>
 let val  result = MlyValue.texpZ (fn _ => let val  (atomictexp as 
atomictexp1) = atomictexp1 ()
 val  (texpl as texpl1) = texpl1 ()
 in (
fn env =>
                                                  let val (env, atomic) = atomictexp env
                                                      val (env, new_args) = texpl env
                                                  in
                                                      case atomic of
                                                          Tycon (tc, ix, old_args) =>
                                                                (env, Tycon (tc, ix, old_args @ new_args))
                                                        | texp => 
                                                               (env, texp)
                                                  end
)
end)
 in ( LrTable.NT 61, ( result, atomictexp1left, texpl1right), rest671)

end
|  ( 155, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.texp texp1,
 _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result
 = MlyValue.atomictexp (fn _ => let val  (texp as texp1) = texp1 ()
 in (texp)
end)
 in ( LrTable.NT 62, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 156, ( ( _, ( MlyValue.TYVAR TYVAR1, (TYVARleft as TYVAR1left), (
TYVARright as TYVAR1right))) :: rest671)) => let val  result = 
MlyValue.atomictexp (fn _ => let val  (TYVAR as TYVAR1) = TYVAR1 ()
 in (
fn env =>
                                        let val (env', tv) = 
                                              case ParseLib.Tyvar.lookup_soft env TYVAR of
                                                NONE => 
                                                   ((#1(argument))(TYVARleft, TYVARright) 
                                                        ("undefined type variable: " ^ TYVAR);
                                                    (env, TV.fromInt ~1))
                                              | SOME tv => (env, tv)
                                        in (env', Typevar tv)
                                        end
)
end)
 in ( LrTable.NT 62, ( result, TYVAR1left, TYVAR1right), rest671)
end
|  ( 157, ( ( _, ( MlyValue.indexrefinement indexrefinement1, _, 
indexrefinement1right)) :: ( _, ( MlyValue.tcname tcname1, (tcnameleft
 as tcname1left), tcnameright)) :: rest671)) => let val  result = 
MlyValue.atomictexp (fn _ => let val  (tcname as tcname1) = tcname1 ()
 val  (indexrefinement as indexrefinement1) = indexrefinement1 ()
 in (
fn env => 
                                        let
                                            val ix1 = indexrefinement env
                                            val (env', tl) = (env, [])
                                            fun process tc1 = (env', Tycon (tc1, ix1, tl))

                                            val (env, result) =
                                                    case ParseLib.Type.lookup ((#1(argument))(tcnameleft,tcnameright)) env tcname of
                                                        ParseLib.SimpleType tc1 => process tc1
                                                      | ParseLib.Datasort(ds, _) => process ds
                                                      | ParseLib.TypeSynonym (tc, tv) =>
                                                             (env, Extypevar tv)
                                        in
                                            ("PARSED type: " ^ Types.typeToString result ^ "\n");
                                            (env, result)
                                        end
)
end)
 in ( LrTable.NT 62, ( result, tcname1left, indexrefinement1right), 
rest671)
end
|  ( 158, ( ( _, ( _, UNIT1left, UNIT1right)) :: rest671)) => let val 
 result = MlyValue.atomictexp (fn _ => (fn env => (env, Product [])))
 in ( LrTable.NT 62, ( result, UNIT1left, UNIT1right), rest671)
end
|  ( 159, ( ( _, ( _, TOP1left, TOP1right)) :: rest671)) => let val  
result = MlyValue.atomictexp (fn _ => (fn env => (env,Top)))
 in ( LrTable.NT 62, ( result, TOP1left, TOP1right), rest671)
end
|  ( 160, ( ( _, ( _, BOT1left, BOT1right)) :: rest671)) => let val  
result = MlyValue.atomictexp (fn _ => (fn env => (env,Bot)))
 in ( LrTable.NT 62, ( result, BOT1left, BOT1right), rest671)
end
|  ( 161, ( ( _, ( MlyValue.texpl texpl1, _, texpl1right)) :: ( _, ( 
MlyValue.atomictexp atomictexp1, atomictexp1left, _)) :: rest671)) =>
 let val  result = MlyValue.texpl (fn _ => let val  (atomictexp as 
atomictexp1) = atomictexp1 ()
 val  (texpl as texpl1) = texpl1 ()
 in (
fn env => 
                                        let val (env',t) = atomictexp env
                                            val (env'',tl) = texpl env'
                                        in (env', t::tl)
                                        end
)
end)
 in ( LrTable.NT 64, ( result, atomictexp1left, texpl1right), rest671)

end
|  ( 162, ( rest671)) => let val  result = MlyValue.texpl (fn _ => (
fn env => (env, [])))
 in ( LrTable.NT 64, ( result, defaultPos, defaultPos), rest671)
end
|  ( 163, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671))
 => let val  result = MlyValue.tcname (fn _ => let val  (ID as ID1) = 
ID1 ()
 in (ID)
end)
 in ( LrTable.NT 0, ( result, ID1left, ID1right), rest671)
end
|  ( 164, ( ( _, ( MlyValue.ID ID1, ID1left, ID1right)) :: rest671))
 => let val  result = MlyValue.id (fn _ => let val  (ID as ID1) = ID1
 ()
 in (ID)
end)
 in ( LrTable.NT 1, ( result, ID1left, ID1right), rest671)
end
|  ( 165, ( ( _, ( _, ASTERISK1left, ASTERISK1right)) :: rest671)) =>
 let val  result = MlyValue.id (fn _ => ("*"))
 in ( LrTable.NT 1, ( result, ASTERISK1left, ASTERISK1right), rest671)

end
|  ( 166, ( ( _, ( _, PLUS1left, PLUS1right)) :: rest671)) => let val 
 result = MlyValue.id (fn _ => ("+"))
 in ( LrTable.NT 1, ( result, PLUS1left, PLUS1right), rest671)
end
|  ( 167, ( ( _, ( _, MINUS1left, MINUS1right)) :: rest671)) => let
 val  result = MlyValue.id (fn _ => ("-"))
 in ( LrTable.NT 1, ( result, MINUS1left, MINUS1right), rest671)
end
|  ( 168, ( ( _, ( _, EQUALOP1left, EQUALOP1right)) :: rest671)) =>
 let val  result = MlyValue.id (fn _ => ("="))
 in ( LrTable.NT 1, ( result, EQUALOP1left, EQUALOP1right), rest671)

end
|  ( 169, ( ( _, ( _, SLASH1left, SLASH1right)) :: rest671)) => let
 val  result = MlyValue.id (fn _ => ("/"))
 in ( LrTable.NT 1, ( result, SLASH1left, SLASH1right), rest671)
end
|  ( 170, ( ( _, ( MlyValue.ID ID3, _, ID3right)) :: ( _, ( 
MlyValue.ID ID2, ID2left, ID2right)) :: ( _, ( MlyValue.ID ID1, 
ID1left, _)) :: rest671)) => let val  result = MlyValue.datasortpair
 (fn _ => let val  ID1 = ID1 ()
 val  ID2 = ID2 ()
 val  ID3 = ID3 ()
 in (
if (ID2 <> "<") andalso (ID2 <> "<=") then ((#1(argument)) (ID2left, ID2right) ("bad subsort declaration: missing `<='"); raise Option)
                                else (ID1, ID3)
)
end)
 in ( LrTable.NT 77, ( result, ID1left, ID3right), rest671)
end
|  ( 171, ( ( _, ( MlyValue.datasortpair datasortpair1, 
datasortpair1left, datasortpair1right)) :: rest671)) => let val  
result = MlyValue.datasortpairs (fn _ => let val  (datasortpair as 
datasortpair1) = datasortpair1 ()
 in ([datasortpair])
end)
 in ( LrTable.NT 78, ( result, datasortpair1left, datasortpair1right),
 rest671)
end
|  ( 172, ( ( _, ( MlyValue.datasortpairs datasortpairs1, _, 
datasortpairs1right)) :: _ :: ( _, ( MlyValue.datasortpair 
datasortpair1, datasortpair1left, _)) :: rest671)) => let val  result
 = MlyValue.datasortpairs (fn _ => let val  (datasortpair as 
datasortpair1) = datasortpair1 ()
 val  (datasortpairs as datasortpairs1) = datasortpairs1 ()
 in (datasortpair :: datasortpairs)
end)
 in ( LrTable.NT 78, ( result, datasortpair1left, datasortpairs1right)
, rest671)
end
|  ( 173, ( rest671)) => let val  result = MlyValue.complement (fn _
 => (fn env => NONE))
 in ( LrTable.NT 80, ( result, defaultPos, defaultPos), rest671)
end
|  ( 174, ( ( _, ( MlyValue.id id1, idleft, (idright as id1right))) ::
 ( _, ( _, ANTICOLON1left, _)) :: rest671)) => let val  result = 
MlyValue.complement (fn _ => let val  (id as id1) = id1 ()
 in (
fn env =>
                          let val (iv, syminfo) = ParseLib.lookup_iv ((#1(argument))(idleft, idright)) env id
                          in
                              case syminfo of
                                  X.IFun _ => SOME iv
                                | _ => ((#1(argument)) (idleft, idright) ("indexpred complement spec is not an index predicate: " ^ id); NONE)
                          end
)
end)
 in ( LrTable.NT 80, ( result, ANTICOLON1left, id1right), rest671)
end
|  ( 175, ( ( _, ( MlyValue.sort sort2, _, sort2right)) :: _ :: ( _, (
 MlyValue.sort sort1, sort1left, _)) :: rest671)) => let val  result =
 MlyValue.indexfunctioncomponent (fn _ => let val  sort1 = sort1 ()
 val  sort2 = sort2 ()
 in (fn env => {domain=sort1 env, range= sort2 env, complement= NONE})

end)
 in ( LrTable.NT 81, ( result, sort1left, sort2right), rest671)
end
|  ( 176, ( rest671)) => let val  result = MlyValue.indexfunctionspec
 (fn _ => (fn env => []))
 in ( LrTable.NT 82, ( result, defaultPos, defaultPos), rest671)
end
|  ( 177, ( ( _, ( MlyValue.indexfunctionspec indexfunctionspec1, _, 
indexfunctionspec1right)) :: ( _, ( MlyValue.indexfunctioncomponent 
indexfunctioncomponent1, _, _)) :: ( _, ( _, COMMA1left, _)) :: 
rest671)) => let val  result = MlyValue.indexfunctionspec (fn _ => let
 val  (indexfunctioncomponent as indexfunctioncomponent1) = 
indexfunctioncomponent1 ()
 val  (indexfunctionspec as indexfunctionspec1) = indexfunctionspec1
 ()
 in (
fn env =>
                                                          let val c = indexfunctioncomponent env
                                                              val rest = indexfunctionspec env
                                                          in
                                                              c :: rest
                                                          end
)
end)
 in ( LrTable.NT 82, ( result, COMMA1left, indexfunctionspec1right), 
rest671)
end
|  ( 178, ( rest671)) => let val  result = MlyValue.indexpredspec (fn
 _ => (fn env => []))
 in ( LrTable.NT 83, ( result, defaultPos, defaultPos), rest671)
end
|  ( 179, ( ( _, ( MlyValue.indexpredspec indexpredspec1, _, 
indexpredspec1right)) :: ( _, ( MlyValue.sort sort1, _, _)) :: ( _, (
 _, COMMA1left, _)) :: rest671)) => let val  result = 
MlyValue.indexpredspec (fn _ => let val  (sort as sort1) = sort1 ()
 val  (indexpredspec as indexpredspec1) = indexpredspec1 ()
 in (
fn env =>
                                                          let val c = {domain= sort env}
                                                              val rest = indexpredspec env
                                                          in
                                                              c :: rest
                                                          end
)
end)
 in ( LrTable.NT 83, ( result, COMMA1left, indexpredspec1right), 
rest671)
end
|  ( 180, ( ( _, ( _, PLUS1left, PLUS1right)) :: rest671)) => let val 
 result = MlyValue.variancesymbol (fn _ => (Sdml.Variance.Co))
 in ( LrTable.NT 9, ( result, PLUS1left, PLUS1right), rest671)
end
|  ( 181, ( ( _, ( _, MINUS1left, MINUS1right)) :: rest671)) => let
 val  result = MlyValue.variancesymbol (fn _ => (Sdml.Variance.Contra)
)
 in ( LrTable.NT 9, ( result, MINUS1left, MINUS1right), rest671)
end
|  ( 182, ( ( _, ( _, ASTERISK1left, ASTERISK1right)) :: rest671)) =>
 let val  result = MlyValue.variancesymbol (fn _ => (Sdml.Variance.Non
))
 in ( LrTable.NT 9, ( result, ASTERISK1left, ASTERISK1right), rest671)

end
|  ( 183, ( rest671)) => let val  result = MlyValue.variancesymbol (fn
 _ => (Sdml.Variance.Non))
 in ( LrTable.NT 9, ( result, defaultPos, defaultPos), rest671)
end
|  ( 184, ( ( _, ( MlyValue.indexspec indexspec1, _, indexspec1right))
 :: ( _, ( MlyValue.tcname tcname1, _, _)) :: ( _, ( _, TYPE1left, _))
 :: rest671)) => let val  result = MlyValue.primdec (fn _ => let val 
 (tcname as tcname1) = tcname1 ()
 val  (indexspec as indexspec1) = indexspec1 ()
 in (
fn env => let val tc = TC.fresh tcname
                             val (env, ispec) = indexspec env
                             val env = ParseLib.Type.extend_libinfo env (tc, ispec)
                             val env = ParseLib.Type.extend env [(tcname, ParseLib.SimpleType tc)]
                                  in
                                      env
                                  end
)
end)
 in ( LrTable.NT 79, ( result, TYPE1left, indexspec1right), rest671)

end
|  ( 185, ( ( _, ( MlyValue.stringseq stringseq1, _, stringseq1right))
 :: _ :: ( _, ( MlyValue.texp texp1, _, _)) :: _ :: ( _, ( 
MlyValue.stringopt stringopt1, _, _)) :: ( _, ( MlyValue.id id1, _, _)
) :: ( _, ( _, FUN1left, _)) :: rest671)) => let val  result = 
MlyValue.primdec (fn _ => let val  (id as id1) = id1 ()
 val  (stringopt as stringopt1) = stringopt1 ()
 val  (texp as texp1) = texp1 ()
 val  (stringseq as stringseq1) = stringseq1 ()
 in (
fn env =>
                             let val sanitized_name = Option.getOpt (stringopt, id)
                                 val pv = PV.sanitary_fresh id sanitized_name
                                 val (_, t) = texp env
                                 val elaboration = stringseq
                                 val env = ParseLib.Pvar.extend_libinfo_primop env (pv, {source_texp= t,
                                                                               elaboration= elaboration, 
                                                                               proper_name= id,
                                                                               sanitized_name= sanitized_name})
                                 val env = ParseLib.Pvar.extend_DefinedVal env [(id, pv)]
                             in
                                 env
                             end
)
end)
 in ( LrTable.NT 79, ( result, FUN1left, stringseq1right), rest671)

end
|  ( 186, ( ( _, ( MlyValue.stringseq stringseq1, _, stringseq1right))
 :: _ :: ( _, ( MlyValue.texp texp1, _, _)) :: _ :: ( _, ( MlyValue.id
 id1, _, _)) :: ( _, ( _, VAL1left, _)) :: rest671)) => let val  
result = MlyValue.primdec (fn _ => let val  (id as id1) = id1 ()
 val  (texp as texp1) = texp1 ()
 val  (stringseq as stringseq1) = stringseq1 ()
 in (
fn env => let val pv = PV.fresh id
                             val (_, t) = texp env
                             val elaboration = stringseq
                             val env = ParseLib.Pvar.extend_libinfo_primop env
                                                                    (pv, {source_texp= t, elaboration= elaboration, proper_name= id,
                                                                          sanitized_name= id})
                             val env = ParseLib.Pvar.extend_DefinedVal env [(id, pv)]
                            in
                                env
                            end
)
end)
 in ( LrTable.NT 79, ( result, VAL1left, stringseq1right), rest671)

end
|  ( 187, ( ( _, ( MlyValue.STRING STRING1, STRING1left, STRING1right)
) :: rest671)) => let val  result = MlyValue.stringseq (fn _ => let
 val  (STRING as STRING1) = STRING1 ()
 in (STRING)
end)
 in ( LrTable.NT 45, ( result, STRING1left, STRING1right), rest671)

end
|  ( 188, ( ( _, ( MlyValue.stringseq stringseq1, _, stringseq1right))
 :: ( _, ( MlyValue.STRING STRING1, STRING1left, _)) :: rest671)) =>
 let val  result = MlyValue.stringseq (fn _ => let val  (STRING as 
STRING1) = STRING1 ()
 val  (stringseq as stringseq1) = stringseq1 ()
 in (String.concat [STRING, "\n", stringseq])
end)
 in ( LrTable.NT 45, ( result, STRING1left, stringseq1right), rest671)

end
|  ( 189, ( ( _, ( MlyValue.STRING STRING1, STRING1left, STRING1right)
) :: rest671)) => let val  result = MlyValue.stringopt (fn _ => let
 val  (STRING as STRING1) = STRING1 ()
 in (SOME STRING)
end)
 in ( LrTable.NT 46, ( result, STRING1left, STRING1right), rest671)

end
|  ( 190, ( rest671)) => let val  result = MlyValue.stringopt (fn _ =>
 (NONE))
 in ( LrTable.NT 46, ( result, defaultPos, defaultPos), rest671)
end
|  ( 191, ( ( _, ( MlyValue.sprodel sprodel1, sprodel1left, 
sprodel1right)) :: rest671)) => let val  result = MlyValue.sort (fn _
 => let val  (sprodel as sprodel1) = sprodel1 ()
 in (
fn env => case sprodel env of
                                [s] => s
                              | sl => X.Product sl
)
end)
 in ( LrTable.NT 68, ( result, sprodel1left, sprodel1right), rest671)

end
|  ( 192, ( ( _, ( _, UNIT1left, UNIT1right)) :: rest671)) => let val 
 result = MlyValue.sort (fn _ => (fn env => X.Product []))
 in ( LrTable.NT 68, ( result, UNIT1left, UNIT1right), rest671)
end
|  ( 193, ( ( _, ( _, _, RBRACE1right)) :: ( _, ( MlyValue.proposition
 proposition1, _, _)) :: _ :: ( _, ( MlyValue.sort sort1, _, _)) :: _
 :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, LBRACE1left, _)) :: 
rest671)) => let val  result = MlyValue.sort (fn _ => let val  (ID as 
ID1) = ID1 ()
 val  (sort as sort1) = sort1 ()
 val  (proposition as proposition1) = proposition1 ()
 in (
fn env =>
                                                          let 
                                                              val sym = IndexSym.fresh ID
                                                              val sort' = sort env
                                                              val env' = ParseLib.extend_iv env [(ID, (sym, X.IUVar sort'))]
                                                              val prop = proposition env'
                                                          in
                                                              X.Subset (sort', sym, prop)
                                                          end
)
end)
 in ( LrTable.NT 68, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 194, ( ( _, ( MlyValue.sort0 sort01, sort01left, sort01right)) ::
 rest671)) => let val  result = MlyValue.sprodel (fn _ => let val  (
sort0 as sort01) = sort01 ()
 in (fn env => [sort0 env])
end)
 in ( LrTable.NT 70, ( result, sort01left, sort01right), rest671)
end
|  ( 195, ( ( _, ( MlyValue.sprodel sprodel1, _, sprodel1right)) :: _
 :: ( _, ( MlyValue.sort0 sort01, sort01left, _)) :: rest671)) => let
 val  result = MlyValue.sprodel (fn _ => let val  (sort0 as sort01) = 
sort01 ()
 val  (sprodel as sprodel1) = sprodel1 ()
 in (fn env => (sort0 env) :: (sprodel env))
end)
 in ( LrTable.NT 70, ( result, sort01left, sprodel1right), rest671)

end
|  ( 196, ( ( _, ( MlyValue.ID ID1, (IDleft as ID1left), (IDright as 
ID1right))) :: rest671)) => let val  result = MlyValue.sort0 (fn _ =>
 let val  (ID as ID1) = ID1 ()
 in (
fn env => let val (sortSym, sort) = ParseLib.lookup_is ((#1(argument))(IDleft, IDright)) env ID
                         in
                             sort
                         end
)
end)
 in ( LrTable.NT 69, ( result, ID1left, ID1right), rest671)
end
|  ( 197, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.sort sort1,
 _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  result
 = MlyValue.sort0 (fn _ => let val  (sort as sort1) = sort1 ()
 in (sort)
end)
 in ( LrTable.NT 69, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 198, ( ( _, ( _, _, RBRACE1right)) :: ( _, ( MlyValue.ID ID1, 
IDleft, IDright)) :: ( _, ( _, LBRACE1left, _)) :: rest671)) => let
 val  result = MlyValue.sort0 (fn _ => let val  (ID as ID1) = ID1 ()
 in (
fn env => let in case ID of
                                "uninterpreted" => 
                                    let 
                                        val sortname = IndexSortSym.fresh "uninterpreted"
                                    in
                                        X.Base sortname
                                    end
                              | _ => ((#1(argument))(IDleft,IDright) "unknown {}-indexsort (known: `uninterpreted')"; raise Debug.StdExcept("", ""))
                                          end
)
end)
 in ( LrTable.NT 69, ( result, LBRACE1left, RBRACE1right), rest671)

end
|  ( 199, ( ( _, ( _, _, RBRACK1right)) :: ( _, ( MlyValue.sort sort1,
 _, _)) :: ( _, ( _, LBRACK1left, _)) :: rest671)) => let val  result
 = MlyValue.sort0 (fn _ => let val  (sort as sort1) = sort1 ()
 in (fn env => X.List (sort env))
end)
 in ( LrTable.NT 69, ( result, LBRACK1left, RBRACK1right), rest671)

end
|  ( 200, ( ( _, ( MlyValue.X_appexp X_appexp1, X_appexp1left, 
X_appexp1right)) :: rest671)) => let val  result = MlyValue.X_exp (fn
 _ => let val  (X_appexp as X_appexp1) = X_appexp1 ()
 in (fn env => X_unflatten (X_appexp env))
end)
 in ( LrTable.NT 71, ( result, X_appexp1left, X_appexp1right), rest671
)
end
|  ( 201, ( ( _, ( MlyValue.X_aexp X_aexp1, (X_aexpleft as X_aexp1left
), (X_aexpright as X_aexp1right))) :: rest671)) => let val  result = 
MlyValue.X_appexp (fn _ => let val  (X_aexp as X_aexp1) = X_aexp1 ()
 in (
fn env => [{item=X_aexp env,
                           loc=(#2(argument)) X_aexpleft X_aexpright, fixity=NONE}]
)
end)
 in ( LrTable.NT 72, ( result, X_aexp1left, X_aexp1right), rest671)

end
|  ( 202, ( ( _, ( MlyValue.id id1, (idleft as id1left), (idright as 
id1right))) :: rest671)) => let val  result = MlyValue.X_appexp (fn _
 => let val  (id as id1) = id1 ()
 in (
fn env =>
                                      let val (v,f) = X_var'n'fix env id ((#1(argument))(idleft, idright))
                                      in [{item=v,
                                           loc=(#2(argument)) idleft idright,
                                           fixity=SOME f}]
                                      end
)
end)
 in ( LrTable.NT 72, ( result, id1left, id1right), rest671)
end
|  ( 203, ( ( _, ( MlyValue.X_appexp X_appexp1, _, X_appexp1right)) ::
 ( _, ( MlyValue.X_aexp X_aexp1, (X_aexpleft as X_aexp1left), 
X_aexpright)) :: rest671)) => let val  result = MlyValue.X_appexp (fn
 _ => let val  (X_aexp as X_aexp1) = X_aexp1 ()
 val  (X_appexp as X_appexp1) = X_appexp1 ()
 in (
fn env => {item=X_aexp env,
                                       loc=(#2(argument)) X_aexpleft X_aexpright,
                                       fixity=NONE}
                            :: (X_appexp env)
)
end)
 in ( LrTable.NT 72, ( result, X_aexp1left, X_appexp1right), rest671)

end
|  ( 204, ( ( _, ( MlyValue.X_appexp X_appexp1, _, X_appexp1right)) ::
 ( _, ( MlyValue.id id1, (idleft as id1left), idright)) :: rest671))
 => let val  result = MlyValue.X_appexp (fn _ => let val  (id as id1)
 = id1 ()
 val  (X_appexp as X_appexp1) = X_appexp1 ()
 in (
fn env => let val (v,f) = X_var'n'fix env id ((#1(argument))(idleft, idright))
                          in {item=v,
                                loc=(#2(argument)) idleft idright,
                                fixity=SOME f} :: (X_appexp env)
                         end
)
end)
 in ( LrTable.NT 72, ( result, id1left, X_appexp1right), rest671)
end
|  ( 205, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( _, LPAREN1left, _))
 :: rest671)) => let val  result = MlyValue.X_aexp (fn _ => (
fn env => X.Tuple []))
 in ( LrTable.NT 73, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 206, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.X_exp 
X_exp1, _, _)) :: _ :: ( _, ( MlyValue.INT INT1, _, _)) :: ( _, ( _, 
HASH1left, _)) :: rest671)) => let val  result = MlyValue.X_aexp (fn _
 => let val  (INT as INT1) = INT1 ()
 val  (X_exp as X_exp1) = X_exp1 ()
 in (fn env => X.Proj (Option.valOf (Int.fromString INT), X_exp env))

end)
 in ( LrTable.NT 73, ( result, HASH1left, RPAREN1right), rest671)
end
|  ( 207, ( ( _, ( MlyValue.INT INT1, INT1left, INT1right)) :: rest671
)) => let val  result = MlyValue.X_aexp (fn _ => let val  (INT as INT1
) = INT1 ()
 in (fn env => X.Literal(X.getIntSort(), INT))
end)
 in ( LrTable.NT 73, ( result, INT1left, INT1right), rest671)
end
|  ( 208, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.X_exp 
X_exp1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let val  
result = MlyValue.X_aexp (fn _ => let val  (X_exp as X_exp1) = X_exp1
 ()
 in (X_exp)
end)
 in ( LrTable.NT 73, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 209, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( MlyValue.X_exp_2c 
X_exp_2c1, _, _)) :: ( _, ( _, LPAREN1left, _)) :: rest671)) => let
 val  result = MlyValue.X_aexp (fn _ => let val  (X_exp_2c as 
X_exp_2c1) = X_exp_2c1 ()
 in (
fn env =>
                                   case X_exp_2c of
                                       [X_exp] => raise Option
                                     | list => X.Tuple (Basic.mapapply list env)
)
end)
 in ( LrTable.NT 73, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 210, ( ( _, ( MlyValue.X_exp_2c X_exp_2c1, _, X_exp_2c1right)) ::
 _ :: ( _, ( MlyValue.X_exp X_exp1, X_exp1left, _)) :: rest671)) =>
 let val  result = MlyValue.X_exp_2c (fn _ => let val  (X_exp as 
X_exp1) = X_exp1 ()
 val  (X_exp_2c as X_exp_2c1) = X_exp_2c1 ()
 in (X_exp :: X_exp_2c)
end)
 in ( LrTable.NT 74, ( result, X_exp1left, X_exp_2c1right), rest671)

end
|  ( 211, ( ( _, ( MlyValue.X_exp X_exp2, _, X_exp2right)) :: _ :: ( _
, ( MlyValue.X_exp X_exp1, X_exp1left, _)) :: rest671)) => let val  
result = MlyValue.X_exp_2c (fn _ => let val  X_exp1 = X_exp1 ()
 val  X_exp2 = X_exp2 ()
 in ([X_exp1, X_exp2])
end)
 in ( LrTable.NT 74, ( result, X_exp1left, X_exp2right), rest671)
end
|  ( 212, ( ( _, ( MlyValue.X_explist0 X_explist01, _, 
X_explist01right)) :: _ :: ( _, ( MlyValue.X_exp X_exp1, X_exp1left, _
)) :: rest671)) => let val  result = MlyValue.X_explist0 (fn _ => let
 val  (X_exp as X_exp1) = X_exp1 ()
 val  (X_explist0 as X_explist01) = X_explist01 ()
 in (X_exp :: X_explist0)
end)
 in ( LrTable.NT 75, ( result, X_exp1left, X_explist01right), rest671)

end
|  ( 213, ( ( _, ( MlyValue.X_exp X_exp1, X_exp1left, X_exp1right)) ::
 rest671)) => let val  result = MlyValue.X_explist0 (fn _ => let val 
 (X_exp as X_exp1) = X_exp1 ()
 in ([X_exp])
end)
 in ( LrTable.NT 75, ( result, X_exp1left, X_exp1right), rest671)
end
|  ( 214, ( ( _, ( MlyValue.X_explist0 X_explist01, X_explist01left, 
X_explist01right)) :: rest671)) => let val  result = 
MlyValue.X_explist (fn _ => let val  (X_explist0 as X_explist01) = 
X_explist01 ()
 in (
fn env =>
                           case X_explist0 of
                               [X_exp] => X_exp env
                             | exps => X.Tuple (Basic.mapapply exps env)
)
end)
 in ( LrTable.NT 76, ( result, X_explist01left, X_explist01right), 
rest671)
end
|  ( 215, ( ( _, ( MlyValue.annotationtype annotationtype1, 
annotationtype1left, annotationtype1right)) :: rest671)) => let val  
result = MlyValue.annotationtypelist (fn _ => let val  (annotationtype
 as annotationtype1) = annotationtype1 ()
 in (
fn env =>
                                         let val (env', anno) = annotationtype env
                                         in
                                             (env', [anno])
                                         end
)
end)
 in ( LrTable.NT 85, ( result, annotationtype1left, 
annotationtype1right), rest671)
end
|  ( 216, ( ( _, ( _, _, RPAREN1right)) :: ( _, ( 
MlyValue.annotationtypelist annotationtypelist1, _, _)) :: ( _, ( _, 
LPAREN1left, _)) :: rest671)) => let val  result = 
MlyValue.annotationtypelist (fn _ => let val  (annotationtypelist as 
annotationtypelist1) = annotationtypelist1 ()
 in (fn env => annotationtypelist env)
end)
 in ( LrTable.NT 85, ( result, LPAREN1left, RPAREN1right), rest671)

end
|  ( 217, ( ( _, ( MlyValue.annotationtypelist annotationtypelist1, _,
 annotationtypelist1right)) :: _ :: ( _, ( MlyValue.annotationtype 
annotationtype1, annotationtype1left, _)) :: rest671)) => let val  
result = MlyValue.annotationtypelist (fn _ => let val  (annotationtype
 as annotationtype1) = annotationtype1 ()
 val  (annotationtypelist as annotationtypelist1) = 
annotationtypelist1 ()
 in (
fn env =>
                         let val (env', anno) = annotationtype env
                             val (env'', annos) = annotationtypelist env'
                         in
                             (env'', anno::annos)
                         end
)
end)
 in ( LrTable.NT 85, ( result, annotationtype1left, 
annotationtypelist1right), rest671)
end
|  ( 218, ( ( _, ( MlyValue.texp texp1, texp1left, texp1right)) :: 
rest671)) => let val  result = MlyValue.annotationtype (fn _ => let
 val  (texp as texp1) = texp1 ()
 in (
fn env =>
                                            let val (env', A) = texp env
                                            in
                                                (env', AnnotationType.Type A)
                                            end
)
end)
 in ( LrTable.NT 84, ( result, texp1left, texp1right), rest671)
end
|  ( 219, ( ( _, ( MlyValue.annotationtype annotationtype1, _, 
annotationtype1right)) :: _ :: ( _, ( MlyValue.sort sort1, _, _)) :: _
 :: ( _, ( MlyValue.ID ID1, _, _)) :: ( _, ( _, SOME1left, _)) :: 
rest671)) => let val  result = MlyValue.annotationtype (fn _ => let
 val  (ID as ID1) = ID1 ()
 val  (sort as sort1) = sort1 ()
 val  (annotationtype as annotationtype1) = annotationtype1 ()
 in (
fn env =>
                             let val sym = IndexSym.fresh ID
                                 val env' = ParseLib.extend_iv env [(ID, (sym, X.IUVar (sort env)))]
                                 val (_, anno) = annotationtype env'
                             in
                                 (env, AnnotationType.Some (sym, sort env', anno))
                             end
)
end)
 in ( LrTable.NT 84, ( result, SOME1left, annotationtype1right), 
rest671)
end
|  ( 220, ( ( _, ( MlyValue.annotationtype annotationtype1, _, 
annotationtype1right)) :: _ :: ( _, ( MlyValue.texp texp1, _, _)) :: _
 :: ( _, ( MlyValue.ID ID1, (IDleft as ID1left), IDright)) :: rest671)
) => let val  result = MlyValue.annotationtype (fn _ => let val  (ID
 as ID1) = ID1 ()
 val  (texp as texp1) = texp1 ()
 val  (annotationtype as annotationtype1) = annotationtype1 ()
 in (
fn env =>
                                         let val (_, A) = texp env
                                             val (pvinfo, pv) = ParseLib.Pvar.lookup ((#1(argument))(IDleft, IDright)) env ID
                                             val (_, anno) = annotationtype env
                                    in
                                        case pvinfo of
                                            ParseLib.Convar => ((#1(argument))(IDleft, IDright) "constructors forbidden in concrete contexts";
                                                           raise Debug.StdExcept("", ""))
                                          | ParseLib.Ordvar _ =>
                                                 (env, AnnotationType.LeftProgramVar (pv, A, anno))
                                    end
)
end)
 in ( LrTable.NT 84, ( result, ID1left, annotationtype1right), rest671
)
end
|  ( 221, ( ( _, ( MlyValue.texp texp1, _, texp1right)) :: ( _, ( _, 
COLON1left, _)) :: rest671)) => let val  result = MlyValue.ctxanno (fn
 _ => let val  (texp as texp1) = texp1 ()
 in (
fn env => let val (_, texp') = texp env
                            in
                                 Sdml.just texp'
                            end
)
end)
 in ( LrTable.NT 86, ( result, COLON1left, texp1right), rest671)
end
| _ => raise (mlyAction i392)
end
val void = MlyValue.VOID
val extract = fn a => (fn MlyValue.program x => x
| _ => let exception ParseInternal
	in raise ParseInternal end) a ()
end
end
structure Tokens : Sdml_TOKENS =
struct
type svalue = ParserData.svalue
type ('a,'b) token = ('a,'b) Token.token
fun EOF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 0,(
ParserData.MlyValue.VOID,p1,p2))
fun ID (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 1,(
ParserData.MlyValue.ID (fn () => i),p1,p2))
fun TYVAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 2,(
ParserData.MlyValue.TYVAR (fn () => i),p1,p2))
fun INT (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 3,(
ParserData.MlyValue.INT (fn () => i),p1,p2))
fun REAL (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 4,(
ParserData.MlyValue.REAL (fn () => i),p1,p2))
fun STRING (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 5,(
ParserData.MlyValue.STRING (fn () => i),p1,p2))
fun CHAR (i,p1,p2) = Token.TOKEN (ParserData.LrTable.T 6,(
ParserData.MlyValue.CHAR (fn () => i),p1,p2))
fun AND (p1,p2) = Token.TOKEN (ParserData.LrTable.T 7,(
ParserData.MlyValue.VOID,p1,p2))
fun ANDALSO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 8,(
ParserData.MlyValue.VOID,p1,p2))
fun AS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 9,(
ParserData.MlyValue.VOID,p1,p2))
fun CASE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 10,(
ParserData.MlyValue.VOID,p1,p2))
fun DATACON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 11,(
ParserData.MlyValue.VOID,p1,p2))
fun DATASORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 12,(
ParserData.MlyValue.VOID,p1,p2))
fun DATATYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 13,(
ParserData.MlyValue.VOID,p1,p2))
fun DO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 14,(
ParserData.MlyValue.VOID,p1,p2))
fun ELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 15,(
ParserData.MlyValue.VOID,p1,p2))
fun END (p1,p2) = Token.TOKEN (ParserData.LrTable.T 16,(
ParserData.MlyValue.VOID,p1,p2))
fun FN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 17,(
ParserData.MlyValue.VOID,p1,p2))
fun FUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 18,(
ParserData.MlyValue.VOID,p1,p2))
fun HANDLE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 19,(
ParserData.MlyValue.VOID,p1,p2))
fun IF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 20,(
ParserData.MlyValue.VOID,p1,p2))
fun IN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 21,(
ParserData.MlyValue.VOID,p1,p2))
fun INDEXCONSTANT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 22,(
ParserData.MlyValue.VOID,p1,p2))
fun INDEXFUN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 23,(
ParserData.MlyValue.VOID,p1,p2))
fun INDEXPRED (p1,p2) = Token.TOKEN (ParserData.LrTable.T 24,(
ParserData.MlyValue.VOID,p1,p2))
fun INDEXSORT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 25,(
ParserData.MlyValue.VOID,p1,p2))
fun LET (p1,p2) = Token.TOKEN (ParserData.LrTable.T 26,(
ParserData.MlyValue.VOID,p1,p2))
fun LETHINT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 27,(
ParserData.MlyValue.VOID,p1,p2))
fun LOCAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 28,(
ParserData.MlyValue.VOID,p1,p2))
fun NOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 29,(
ParserData.MlyValue.VOID,p1,p2))
fun OF (p1,p2) = Token.TOKEN (ParserData.LrTable.T 30,(
ParserData.MlyValue.VOID,p1,p2))
fun OP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 31,(
ParserData.MlyValue.VOID,p1,p2))
fun ORELSE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 32,(
ParserData.MlyValue.VOID,p1,p2))
fun PRIMITIVE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 33,(
ParserData.MlyValue.VOID,p1,p2))
fun RAISE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 34,(
ParserData.MlyValue.VOID,p1,p2))
fun REC (p1,p2) = Token.TOKEN (ParserData.LrTable.T 35,(
ParserData.MlyValue.VOID,p1,p2))
fun TESTSUBTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 36,(
ParserData.MlyValue.VOID,p1,p2))
fun THEN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 37,(
ParserData.MlyValue.VOID,p1,p2))
fun TRY (p1,p2) = Token.TOKEN (ParserData.LrTable.T 38,(
ParserData.MlyValue.VOID,p1,p2))
fun TYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 39,(
ParserData.MlyValue.VOID,p1,p2))
fun UNIT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 40,(
ParserData.MlyValue.VOID,p1,p2))
fun VAL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 41,(
ParserData.MlyValue.VOID,p1,p2))
fun WHERE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 42,(
ParserData.MlyValue.VOID,p1,p2))
fun WITH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 43,(
ParserData.MlyValue.VOID,p1,p2))
fun WITHTYPE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 44,(
ParserData.MlyValue.VOID,p1,p2))
fun ANTICOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 45,(
ParserData.MlyValue.VOID,p1,p2))
fun APOSTROPHE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 46,(
ParserData.MlyValue.VOID,p1,p2))
fun ARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 47,(
ParserData.MlyValue.VOID,p1,p2))
fun ASTERISK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 48,(
ParserData.MlyValue.VOID,p1,p2))
fun BAR (p1,p2) = Token.TOKEN (ParserData.LrTable.T 49,(
ParserData.MlyValue.VOID,p1,p2))
fun COLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 50,(
ParserData.MlyValue.VOID,p1,p2))
fun COMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 51,(
ParserData.MlyValue.VOID,p1,p2))
fun DARROW (p1,p2) = Token.TOKEN (ParserData.LrTable.T 52,(
ParserData.MlyValue.VOID,p1,p2))
fun DBLCOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 53,(
ParserData.MlyValue.VOID,p1,p2))
fun DBLCOMMA (p1,p2) = Token.TOKEN (ParserData.LrTable.T 54,(
ParserData.MlyValue.VOID,p1,p2))
fun DQUESTION (p1,p2) = Token.TOKEN (ParserData.LrTable.T 55,(
ParserData.MlyValue.VOID,p1,p2))
fun EQUALOP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 56,(
ParserData.MlyValue.VOID,p1,p2))
fun HASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 57,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 58,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 59,(
ParserData.MlyValue.VOID,p1,p2))
fun LBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 60,(
ParserData.MlyValue.VOID,p1,p2))
fun RBRACK (p1,p2) = Token.TOKEN (ParserData.LrTable.T 61,(
ParserData.MlyValue.VOID,p1,p2))
fun LPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 62,(
ParserData.MlyValue.VOID,p1,p2))
fun RPAREN (p1,p2) = Token.TOKEN (ParserData.LrTable.T 63,(
ParserData.MlyValue.VOID,p1,p2))
fun MINUS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 64,(
ParserData.MlyValue.VOID,p1,p2))
fun PLUS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 65,(
ParserData.MlyValue.VOID,p1,p2))
fun SEMICOLON (p1,p2) = Token.TOKEN (ParserData.LrTable.T 66,(
ParserData.MlyValue.VOID,p1,p2))
fun TURNSTILE (p1,p2) = Token.TOKEN (ParserData.LrTable.T 67,(
ParserData.MlyValue.VOID,p1,p2))
fun WILD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 68,(
ParserData.MlyValue.VOID,p1,p2))
fun SOME (p1,p2) = Token.TOKEN (ParserData.LrTable.T 69,(
ParserData.MlyValue.VOID,p1,p2))
fun PERIOD (p1,p2) = Token.TOKEN (ParserData.LrTable.T 70,(
ParserData.MlyValue.VOID,p1,p2))
fun LEFTANNO (p1,p2) = Token.TOKEN (ParserData.LrTable.T 71,(
ParserData.MlyValue.VOID,p1,p2))
fun TOP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 72,(
ParserData.MlyValue.VOID,p1,p2))
fun BOT (p1,p2) = Token.TOKEN (ParserData.LrTable.T 73,(
ParserData.MlyValue.VOID,p1,p2))
fun AMP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 74,(
ParserData.MlyValue.VOID,p1,p2))
fun SLASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 75,(
ParserData.MlyValue.VOID,p1,p2))
fun DBLAMP (p1,p2) = Token.TOKEN (ParserData.LrTable.T 76,(
ParserData.MlyValue.VOID,p1,p2))
fun DBLSLASH (p1,p2) = Token.TOKEN (ParserData.LrTable.T 77,(
ParserData.MlyValue.VOID,p1,p2))
fun DASHALL (p1,p2) = Token.TOKEN (ParserData.LrTable.T 78,(
ParserData.MlyValue.VOID,p1,p2))
fun DASHEXISTS (p1,p2) = Token.TOKEN (ParserData.LrTable.T 79,(
ParserData.MlyValue.VOID,p1,p2))
end
end
